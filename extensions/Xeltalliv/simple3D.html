<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Simple 3D - TurboWarp Extension Documentation</title>
    <link rel="canonical" href="https://extensions.turbowarp.org/Xeltalliv/simple3D">
    <style>
      :root {
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        color-scheme: light dark;
        font-size: 16px;
      }
      @media (prefers-color-scheme: dark) {
        :root {
          color: #eee;
          background: #131313;
        }
      }

      @media (prefers-color-scheme: dark) {
        a {
          color: #56b2ff;
        }
        a:visited {
          color: #f192ff;
        }
        a:active {
          color: red;
        }
      }

      body {
        margin: 0;
        padding: 0;
        line-height: 1.3;
      }

      nav {
        background-color: #ff4c4c;
        color: white;
        font-weight: bold;
        font-size: 1.1em;
      }
      nav > div {
        display: flex;
        max-width: 600px;
        margin: 0 auto;
        justify-content: space-between;
      }
      nav a {
        display: flex;
        gap: 0.5rem;
        padding: 0.5rem 0.25rem 0.5rem 0;
        align-items: center;
        text-decoration: none;
        color: inherit !important;
      }
      nav a:hover {
        text-decoration: underline;
      }
      nav img {
        width: 2rem;
        height: 2rem;
        flex-shrink: 0;
      }
      @media (prefers-color-scheme: dark) {
        nav {
          background-color: #333;
        }
      }

      noscript {
        font-weight: bold;
      }

      .container {
        max-width: 600px;
        margin: auto;
        padding: 0 0.25rem;
      }
      h1 {
        font-size: 2.25rem;
      }
      h1, h2, h3, h4, h5, h6 {
        border-bottom: 1px solid #ccc;
      }
      hr {
        border: none;
        border-top: 1px solid #ccc;
        margin: 1rem 0;
      }
      @media (prefers-color-scheme: dark) {
        hr, h1, h2, h3, h4, h5, h6 {
          border-color: #444;
        }
      }

      .view-in-browser {
        display: none;
      }
      .is-desktop .view-in-browser {
        display: flex;
      }
      .is-desktop nav > div, .is-desktop .container {
        /* Desktop app shows this page in a window, not a browser tab, so don't need to */
        /* restrict the width of the content for readability. */
        max-width: 100%;
      }

      code {
        background-color: #eee;
        border-radius: 4px;
        padding: 0 2px;
      }
      pre {
        background-color: #eee;
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 4px;
        overflow-x: auto;
      }
      @media (prefers-color-scheme: dark) {
        code, pre {
          background-color: #223;
          border-color: #334;
        }
      }

      .render-scratchblocks {
        width: 100%;
        overflow-x: auto;
        white-space: pre;
        line-height: 42px; /* reasonable estimation to reduce layout shift */
      }
      .render-scratchblocks svg {
        display: block;
      }

      footer {
        margin: 1rem 0;
        font-size: small;
      }
    </style>
  </head>
  <body>
    <nav role="navigation">
      <div>
        <a href="https://extensions.turbowarp.org/">
          <img src="/turbowarp.svg" alt="">
          <span>TurboWarp Extension Gallery</span>
        </a>

        <!-- Only used by desktop app -->
        <a class="view-in-browser" href="https://extensions.turbowarp.org/Xeltalliv/simple3D">
          Read in browser
        </a>
      </div>
    </nav>

    <main class="container">
      <h1>Simple 3D</h1>

      <noscript><p>Enable JavaScript for blocks to render.</p></noscript>

      <h2>Table of contents</h2>
<ol>
<li><a href="#description">What is this</a></li>
<li><a href="#main-concepts">How it works</a></li>
<li><a href="#simple-drawing">Drawing things</a></li>
<li><a href="#transformations">Setting up transformations</a></li>
<li><a href="#step-order">Order in which different steps are performed</a></li>
<li><a href="#blocks">Blocks</a><br>
6.1. <a href="#blocks-clearing">Clearing</a><br>
6.2. <a href="#blocks-meshes">Meshes</a><br>
6.3. <a href="#blocks-textures">Textures</a><br>
6.4. <a href="#blocks-text-measurement">Text measurement</a><br>
6.5. <a href="#blocks-fonts">Fonts</a><br>
6.6. <a href="#blocks-view-transformations">View transformations</a><br>
6.7. <a href="#blocks-manual-transformations">Manual transformations</a><br>
6.8. <a href="#blocks-rendertargets">Rendering into textures</a><br>
6.9. <a href="#blocks-tinting-fog">Tinting and fog</a><br>
6.10. <a href="#blocks-resolution">Resolution changes</a></li>
<li><a href="#ext-integration">Integration with other extensions</a><br>
7.1. <a href="#ar-integration">Augmented Reality extension</a></li>
</ol>
<h2>What is this <a name="description"></a></h2>
<p><strong>Simple 3D</strong> is an extension by <a href="https://scratch.mit.edu/users/Vadik1">Vadik1</a> meant to enable creation of GPU accelerated 3D projects. It is not designed for making graphically complex 3D projects (for that, see <a href="https://github.com/TurboWarp/extensions/pull/1377">Pen+ v7</a> and <a href="https://github.com/TurboWarp/extensions/discussions/378">WebGL2</a> extensions, both with programmable shaders) and instead it's main focus is allowing people to create 3D projects easily and quickly. Nevertheless, despite lack of programmable shaders, it is still quite powerful. It covers the wide range of usages from something as high level as making an <a href="#ar-example">AR project in less than 20 blocks</a> with models loaded from OBJ files, to something more low level like doing all the calculations on CPU and streaming transformed polygons every frame (like <a href="https://extensions.turbowarp.org/obviousAlexC/penPlus.js">Pen+</a>). And of course everything in-between.</p>
<p>It could also be useful for making certain kinds of 2D projects, thanks to it's ability to render large quantities of similar objects with instancing (e.g. particles), construct 2D meshes out of triangles, rendering into textures allowing multi-pass rendering and more advanced clipping than <a href="https://extensions.turbowarp.org/Xeltalliv/clippingblending.js">Clipping &amp; Blending</a> extension. It can be used for 2D image processing that can for example later be used as costumes using <a href="https://extensions.turbowarp.org/Lily/Skins.js">Skins</a> extension. It's support of vertex weights and indices can be used for skeletal animation of 2D characters with deforming body parts rather than using rigid images, or even for smoothly extending UI elements.</p>
<h2>How it works <a name="main-concepts"></a></h2>
<p>Scratch has a background layer, a video layer, a pen layer and a sprite layer. This extension adds another layer - simple3D between video and pen layers. <strong>High quality pen mode also affects it.</strong></p>
<p>The key concepts in this extension are the meshes and transformations.</p>
<p>Meshes store the 3D model data and can be drawn. They are kind of like costumes in a stamp-based project. That is, if you want to make a project that draws many copies of some costume in different locations using stamps, you will only have 1 costume, store all the locations in a list in whatever format you consider appropriate, and every frame you will clear the screen and re-stamp that costume in all the locations from the list.</p>
<p>It works the same way with this extension. If you have 10 identical 3D boxes, you will only create one mesh. Then every frame, first clear the screen, and after that loop over the list, for each box, setting up the correct transformation and drawing that one mesh.</p>
<p>So in short, <strong>this extension does not have any kind of scenes, objects, cameras, etc</strong>, you have to keep track of it yourself.</p>
<hr>
<p>3D models consist of vertices which together form primitives (points, lines, triangles). Each vertex has either 2D (XY) or 3D (XYZ) location described with 2 or 3 numbers respectively. Before drawing the mesh, you would usually set up transformation, which tells how to take those initial locations and transform them to correct location on your 2D screen. The typical way to do it, is to chain multiple simple transformations together. Simple transformations can be translation (offsetting), rotation, scaling, mirroring, skewing, etc.</p>
<h2>Drawing things <a name="simple-drawing"></a></h2>
<p><strong>Note:</strong> For a more complete tutorial, see <a href="https://xeltalliv.github.io/simple3d-extension/examples/">here</a> (external link).</p>
<p>For now let's not worry about transformations and just draw something as is.<br>
First step would be to clear the screen:</p>
<div class="render-scratchblocks">set clear color R: (0.5) G: (0.5) B: (0.5) A: (1) :: sensing
clear (color and depth v) :: sensing
</div><p>After running that the screen should turn gray.<br>
Now let's draw 2 triangles arranged into a rectangle. First create a mesh:</p>
<div class="render-scratchblocks">create mesh [my mesh] :: sensing
</div><p>Then create 2 lists <code>posX</code> and <code>posY</code>.<br>
Fill <code>posX</code> with:</p>
<pre class="language-">-0.9
0.9
-0.9
-0.9
0.9
0.9
</pre><p>Fill <code>posY</code> with:</p>
<pre class="language-">-0.9
-0.9
0.9
0.9
-0.9
0.9
</pre><p>then set mesh's positions to it:</p>
<div class="render-scratchblocks">set [my mesh] positions XY [posX v] [posY v] :: sensing
</div><p>and finally draw it:</p>
<div class="render-scratchblocks">draw [my mesh] :: sensing
</div><p>The result should look something like this:<br>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAloAAAHEAgMAAACcsWzXAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV/TSkUqImYQcchQnSyCiohTrUIRKoRaoVUH89EvaNKQpLg4Cq4FBz8Wqw4uzro6uAqC4AeIs4OToouU+L+k0CLGg+N+vLv3uHsHcI2KolmhOKDptplOJoRsblUIvyIEHv2YxbikWMacKKbgO77uEWDrXYxl+Z/7c/SqeUsBAgJxXDFMm3iDeHrTNhjvE/NKSVKJz4nHTLog8SPTZY/fGBdd5lgmb2bS88Q8sVDsYLmDlZKpEU8RR1VNp3wu67HKeIuxVqkprXuyF0by+soy02kOI4lFLEGEABk1lFGBjRitOikW0rSf8PEPuX6RXDK5ylDIsYAqNEiuH+wPfndrFSYnvKRIAuh6cZyPESC8CzTrjvN97DjNEyD4DFzpbX+1Acx8kl5va9EjoG8buLhua/IecLkDDD4Zkim5UpAmVygA72f0TTlg4BboWfN6a+3j9AHIUFepG+DgEBgtUva6z7u7O3v790yrvx8KVHLj7WPAsgAAAAlQTFRFNDQ0gICA////76SQuwAAAAlwSFlzAAAYTAAAGHQBn6hAIAAAAAd0SU1FB+gEFBIAAu2UQ3UAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAABNUlEQVR42u3OUQkAIBAFsCthH0toR01pAX+FB24JVhWqjUTdy8vLy8vLy8vLy8vr99fcEZaXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5fX7RXGy8vLy8vLy8vLy8vr/SvUAWUTfy76T1mWAAAAAElFTkSuQmCC" alt="white rectangle on gray background"><br>
The screen coordinate system used by this extension is not scratch's typical 480x360 (from -240 to 240 for X and from -180 to 180 for Y), but instead it is 2x2 (from -1 to 1 on both axis). It is the same as in WebGL and OpenGL.<br>
Here we created triangles that have vertex coordinates at -0.9 and 0.9, which do not quite reach the boundaries of the screen, even though they get close.</p>
<p>Also, here we specified 6 vertices. Each triangle has 3 vertices, so it was treated as 6/3=2 triangles.<br>
But specifying 3 vertices per each triangle is not the only way. In cases when some vertices are the same for multiple triangles, there are ways to specify them once and reuse them afterwards rather than duplicating the data. There are 2 main ways to do it:</p>
<h3>List of indices</h3>
<p>With this way, there is a way to create another list which will reference which vertices to use in which order. To add it to our example:<br>
Fill <code>posX</code> with:</p>
<pre class="language-">-0.9
0.9
-0.9
0.9
</pre><p>Fill <code>posY</code> with:</p>
<pre class="language-">-0.9
-0.9
0.9
0.9
</pre><p>Create another list <code>indices</code> and fill it with:</p>
<pre class="language-">1
2
3
3
2
4
</pre><p>Now reupload XY positions and upload the list of indices into the mesh, clear the screen and draw the mesh again. Result should look the same.</p>
<div class="render-scratchblocks">set clear color R: (0.5) G: (0.5) B: (0.5) A: (1) :: sensing
clear (color and depth v) :: sensing
create mesh [my mesh] :: sensing
set [my mesh] positions XY [posX v] [posY v] :: sensing
set [my mesh] vertex indices [indices v] :: sensing
draw [my mesh] :: sensing
</div><h3>Chained primitive types</h3>
<p>Another way to do it is to switch mesh from using just &quot;triangles&quot; to using &quot;triangle strips&quot; or &quot;triangle fans&quot;.<br>
With triangle strip, the first 2 vertices are processed normally, and then each subsequent vertex get combined with the previous 2 into a triangle.<br>
With triangle fan, the first 2 vertices are processed normally, and then each subsequent vertex get combined with the previous one and the first one into a triangle.</p>
<div class="render-scratchblocks">set clear color R: (0.5) G: (0.5) B: (0.5) A: (1) :: sensing
clear (color and depth v) :: sensing
create mesh [my mesh] :: sensing
set [my mesh] positions XY [posX v] [posY v] :: sensing
set [my mesh] primitives (traingle strip v) :: sensing
draw [my mesh] :: sensing
</div><p>Result should once again look the same.</p>
<h3>Primitive restart index</h3>
<p>&quot;triangle strips&quot; and &quot;triangle fans&quot; are no doubt efficient, but when using it you only get 1 long continious thing of triangles, meaning that to draw many &quot;strips&quot; or &quot;fans&quot; you will have to call &quot;draw mesh&quot; many times, cancelling the efficiency.<br>
However there is a solution for it. You can use &quot;triangle strips&quot; and &quot;triangle fans&quot; together with list of indices. If you specify index 0 or below, it will interrupt the previous chain of triangles and restart a new one.</p>
<p>Same applies to &quot;line strip&quot; and &quot;line loop&quot;.</p>
<h2>Setting up transformations <a name="transformations"></a></h2>
<p>The typical sequence of simple transformation for 3D project goes like this:<br>
First you start off with having a 3D model in it's own coordinate system (model space), with all vertex positions stored relatively from it's origin. The first step would be to transform it to the world coordinate system. If the object has it's own rotation, rotate every vertex around it's origin (0,0,0) by correct amount of degrees. If it is scaled, scale them. Then once that is done, offset every vertex by object's world position. Now positions of all of the vertices are in the world coordinate system (world space).</p>
<p>The next step is to transfrorm them to the coordinate system relatively to the viewer, where viewer is at X:0, Y:0, Z:0 and is always facing negative Z. In 3D projects on normal scratch it is common for viewer to face positive Z, where the more Z something has, the further away it is in front of the viewer, but in case of this extension, it was designed like most software outside scratch - the <strong>less</strong> Z something has, the further it is in front of the viewer. To do this transformation, first subtract camera position from position of every vertex. That will place the camera in the origin of the world and make everything relatively to it, but rotation is still not taken into a count. To use it, rotate every point by negated/inverse camera rotation.</p>
<p>What you now have are 3D positions relatively to the camera. But your screen is 2D, so the last step is to do the projection. The general gist of it is that you divide all X and Y by Z, so that the further something is, the smaller it is and the closer it is to the center of the screen. And while doing that, clipping everything that goes offscreen or too close and behind you.</p>
<p>But in reality it's somewhat more complicated.<br>
You first transform X, Y, Z into X, Y, Z and W of the clip space and then GPU automatically clips X, Y and Z to the rangle from -W to W, and then divides<br>
X, Y, Z by W, so X, Y, Z end up in range from -1 to 1. Where W is the actual depth, while Z is depth converted to the correct range to be used with the<br>
depth buffer (everything below -1 and above 1 gets clipped) (too far and too close).</p>
<p>If that sounded complicated, do not worry, Simple3D extension mostly handles it for you.</p>
<p>So let's recap:</p>
<pre class="language-">when given vertex coordinates x, y, z in model space:

scale by object scale
rotate by object orientation
translate by object position

translate by negative camera position
rotate by negative camera orientation

convert to clip space

divide X,Y,Z by depth W (done by GPU, cannot be controlled)
draw to the screen at X,Y. Use Z for depth check.
</pre><p>And now it's time to make some actual Simple3D scratch blocks code.<br>
In Simple3D those transformations are combined into 1 big transformation, and all the steps have to be specified in reverse.</p>
<div class="render-scratchblocks">start with perspective FOV (90) near (0.1) far (1000) :: sensing
rotate around [X v] by ((0) - (camRotX)) degrees :: sensing
rotate around [Y v] by ((0) - (camRotY)) degrees :: sensing
move X ((0) - (camX)) Y ((0) - (camY)) Z ((0) - (camZ)) :: sensing
move X (objectX) Y (objectY) Z (objectZ) :: sensing
rotate around [Y v] by (objectRotY) degrees :: sensing
rotate around [X v] by (objectRotX) degrees :: sensing
scale X (objectSizeX) Y (objectSizeY) Z (objectSizeZ) :: sensing
draw mesh [my mesh] :: sensing
</div><p>Doing all of those steps again for every mesh you want to draw is inefficient. This is where doing steps in reverse becomes helpful. Combined with wrapper block, which saves the transformation when entering it, and restores it when exiting it, it is possible to do this:</p>
<div class="render-scratchblocks">start with perspective FOV (90) near (0.1) far (1000) :: sensing
rotate around [X v] by ((0) - (camRotX)) degrees :: sensing
rotate around [Y v] by ((0) - (camRotY)) degrees :: sensing
move X ((0) - (camX)) Y ((0) - (camY)) Z ((0) - (camZ)) :: sensing
repeat (10)
wrapper {
...
move X (objectX) Y (objectY) Z (objectZ) :: sensing
rotate around [Y v] by (objectRotY) degrees :: sensing
rotate around [X v] by (objectRotX) degrees :: sensing
scale X (objectSizeX) Y (objectSizeY) Z (objectSizeZ) :: sensing
draw mesh [my mesh] :: sensing
} :: sensing
end
</div><p>This will work and it is efficient, however this extension also provides advanced features like fog, instancing, billboarding, which need to intervine in some of the intermediate steps.<br>
And when you create one large transformation by youself, it has no way of doing that. Which is why, currently the correct way to setup transformations is like this:</p>
<div class="render-scratchblocks">configure [to projected from view space v] transformation :: sensing
start with perspective FOV (90) near (0.1) far (1000) :: sensing

configure [to view space from world space v] transformation :: sensing
start with no transformation :: sensing
rotate around [X v] by ((0) - (camRotX)) degrees :: sensing
rotate around [Y v] by ((0) - (camRotY)) degrees :: sensing
move X ((0) - (camX)) Y ((0) - (camY)) Z ((0) - (camZ)) :: sensing
repeat (10)
...
configure [to world space from model space v] transformation :: sensing
start with no transformation :: sensing
move X (objectX) Y (objectY) Z (objectZ) :: sensing
rotate around [Y v] by (objectRotY) degrees :: sensing
rotate around [X v] by (objectRotX) degrees :: sensing
scale X (objectSizeX) Y (objectSizeY) Z (objectSizeZ) :: sensing
draw mesh [my mesh] :: sensing
end
</div><p>The extension allows you to split your large transformation into 3 separate transformations, which will be applied sequentially, allowing some of the features to do their thing inbetween.<br>
It also allows you to easily got between different coordinate systems using those blocks:</p>
<div class="render-scratchblocks">transform X (0) Y (0) Z (0) from [world space v] to [model space v] :: sensing
transform direction X (0) Y (0) Z (0) from [world space v] to [model space v] :: sensing
</div><h2>Order in which different steps are performed <a name="step-order"></a></h2>
<h3>Vertex positions</h3>
<p>For each vertex, the final position calculation goes as follows:</p>
<ol>
<li>vertex position is read</li>
<li>skinning is applied</li>
<li>transformed from model space to world space</li>
<li>transformed by instance transform</li>
<li>transformed from world space to view space</li>
<li>transformed from veiw space to clip space</li>
<li>division of XYZ by W (performed automatically by the GPU)</li>
</ol>
<p>When billboarding is enabled:</p>
<ol>
<li>vertex position is read</li>
<li>skinning is applied</li>
<li>transformed from model space to world space</li>
<li>position is copied elsewhere, while original is replaced by (0,0,0)</li>
<li>transformed by instance transform</li>
<li>transformed from world space to view space</li>
<li>saved position is added to current position</li>
<li>transformed from veiw space to clip space</li>
<li>division of XYZ by W (performed automatically by the GPU)</li>
</ol>
<h3>Vertex colors</h3>
<ol>
<li>vertex color is read, white if not provided</li>
<li>multipled by instance color</li>
</ol>
<h3>Vertex UVs</h3>
<p>For each vertex, the UV texture coordinates at it are calculated as follows:</p>
<ol>
<li>vertex UVs are read</li>
<li>scaled by instance UV scale (3rd and 4th components)</li>
<li>added instance UV offset (1st and 2nd components)</li>
<li>mesh UV offset is applied</li>
</ol>
<h3>Pixel Colors</h3>
<p>For each pixel, the final color calculation goes as follows:</p>
<ol>
<li>texture is read or white if texture is not provided</li>
<li>multipled by interpolated vertex color RGBA</li>
<li>alpha threshold check is performed</li>
<li>make opaque is applied</li>
<li>multipled by global color multipler</li>
<li>added global color adder</li>
<li>fog is aplied</li>
</ol>
<h2>Blocks <a name="blocks"></a></h2>
<h3>Clearing <a name="blocks-clearing"></a></h3>
<div class="render-scratchblocks">reset everything :: sensing
</div><p>Resets everything to the initial state as if the extension was freshly loaded. It also deletes meshes and shader cache.</p>
<hr>
<div class="render-scratchblocks">clear (color and depth v) :: sensing
</div><p>Clears the color and/or depth of the selected render target.</p>
<hr>
<div class="render-scratchblocks">set clear color R:(0.5) G:(0.5) B:(0.5) A:(1) :: sensing
</div><p>Sets clear color to the specified Red, Green, Blue and Alpha (Opacity) values in range from 0 to 1.<br>
Clear color is a global value.</p>
<hr>
<div class="render-scratchblocks">set depth test (closer v) write (on v) :: sensing
</div><p>Before new pixel is drawn, it's depth is compared to the pixel already drawn on that location.<br>
If it passes according to the check in the first argument of this block, it gets drawn. If it fails, the new pixel gets discarded, and whatever was there remains there.<br>
The second argument controls when check passes whether only color should be updated or both color and depth value. Turning this off can be useful for drawing transparent things, which should react to already drawn opaque things, while not modifying depth to not interfer with each other.<br>
<strong>Depth test and write are values that are saved separately for each render target.</strong><br>
Despite all 6 sides of the cube texture being different render targets, they still share those values.</p>
<p>For stage, default values are &quot;closer&quot; and &quot;on&quot;. <strong>However, for textures used as render targets default values are &quot;everything&quot; and &quot;off&quot;.</strong> Memory for storing depth is not even allocated until depth write is set to &quot;on&quot;.</p>
<h3>Meshes <a name="blocks-meshes"></a></h3>
<div class="render-scratchblocks">(all meshes :: sensing)
</div><p>Lists all the mesh names separated by commas. Mainly meant to be used manually for debugging purposes.</p>
<hr>
<div class="render-scratchblocks">create mesh [my mesh] :: sensing
</div><p>Creates an empty mesh with the specified name. If mesh with such name already exists, the old one gets fully deleted first.</p>
<p>Also, whitespaces at both ends of the name, as well as any commas get removed from the mesh name. This is done for compatibility with &quot;make mesh inhert&quot; block.</p>
<hr>
<div class="render-scratchblocks">delete mesh [my mesh] :: sensing
</div><p>Deletes mesh with the specified name.</p>
<hr>
<div class="render-scratchblocks">make mesh [my mesh 3] inherit from meshes [my mesh 1,my mesh 2] :: sensing
</div><p>Sets up the first mesh to inherit any lists or properties from multiple other meshes.<br>
If multiple other meshes have the same property, the last one takes the priority.<br>
If any of the specified meshes to inherit form a cyclic dependancy, the entire operation fails.<br>
Names are provided in a comma separated list. Mesh names are trimmed from spaces on both ends. So <code>my mesh 1,my mesh 2</code>, <code>my mesh 1, my mesh 2</code>, and <code>   my mesh 1    ,   my mesh 2  </code> will all behave the same.</p>
<p>This is the a key feature meant to avoid data duplication. When using it, nothing that could be expensive is duplicated.<br>
<strong>Use this instead of uploading the same lists or textures into multiple different meshes.</strong><br>
You can even rapidly change what meshes are inherited while the project is running.</p>
<hr>
<div class="render-scratchblocks">(mesh [my mesh] [inherits from v] :: sensing)
</div><p>Used to obtain properties of a mesh.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] vertex indices [list v] :: sensing
</div><p>An optional mesh list used to provide the order in which vertices are read and used to construct primitives.<br>
Starts from 1. Specifying value 0 or below can be used to break up &quot;triangle strip&quot;, &quot;traingle fan&quot;, &quot;line strip&quot; and &quot;line loop&quot; into multiple ones.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] positions XY [listX v] [listY v] :: sensing
set [my mesh] positions XYZ [listX v] [listY v] [listZ v] :: sensing
</div><p>Used to upload vertex positions into the mesh.<br>
<strong>The only mandatory list for mesh to become drawable.</strong></p>
<hr>
<div class="render-scratchblocks">set [my mesh] colors RGB [listR v] [listG v] [listB v] :: sensing
set [my mesh] colors RGBA [listR v] [listG v] [listB v] [listA v] :: sensing
</div><p>Used to upload vertex colors (as red, green, blue and alpha) into the mesh.<br>
Values mush be integers in range between 0 and 255.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] texture coordinates UV [listU v] [listV v] :: sensing
set [my mesh] texture coordinates UVW [listU v] [listV v] [listW v] :: sensing
</div><p>Used to upload texture coordinates into the mesh.<br>
The 2 component one is used for 2D textures. Specifies 2D coordinates on a texture, which go from 0 to 1. But values outside of those bounds are also valid and useful.<br>
The 3 component one is used for cube textures (cubemaps). Specifies 3D direction from the center, which will be intersected with the cube around it.<br>
If texture coordinates are specified, but texture is not, the default texture is used.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] texture () [clamp to edge v] [pixelated v] :: sensing
set [my mesh] cube texture (X+ v) () [clamp to edge v] [pixelated v] :: sensing
</div><p>Used to upload texture into the mesh.<br>
Calling this block depending on the type of texture used either uploads texture instantly (e.g. empty or text) or schedules texture to be uploaded into the mesh some time in the future (e.g. load from url or from costume).<br>
<strong>So if for example you upload texture from a costume and immediately try to draw this mesh once, you will not see it. It takes time to load!</strong></p>
<p>Use the block below to check if the texture has finished loading.</p>
<div class="render-scratchblocks">(mesh [my mesh] [texture is loading v] :: sensing)
</div><p>The 2nd(3rd) argument controls what happens when UV coordinates are out of 0..1 range:</p>
<ul>
<li><code>clamp to edge</code> - will find the closest point within allowed range and use color of that. This basically infinitely stretches edges of the texture.</li>
<li><code>repeat</code> - the texture is repeated out of bounds. UV 1.5 0.6 is the same as 13.5 -0.4</li>
</ul>
<p>The 3rd(4th) argument controls how each pixel obtains the color from the texture:</p>
<ul>
<li><code>pixelated</code> - rounds down UV to the coordinates the closest pixel and gets it's color</li>
<li><code>blurred</code> - takes a weighted average between 4 pixels UV falls inbetween</li>
</ul>
<p>The 1st argument in cube texture controls to which of 6 sides the texture should be uploaded. It must be square and the same size as all other sides.<br>
Uploading non-matching size will cause all other sides to clear themselves.<br>
Uploading non-square size texture will fail and do nothing.</p>
<p>The type of texture that the mesh will have can only be set once. If the mesh has cube texture, trying to replace it with the 2D texture will fail. If the mesh has 2D texture, trying to replace it with the cube texture will also fail.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] texture mipmapping [off v] :: sensing
</div><p>Used for enabling and disabling mipmapping.<br>
When enabling, regenerates mipmaps.<br>
When mipmapping is enabled, uploading textures regenerates mipmaps as well.</p>
<p>Mipmapping is a technique of having texture in multiple different resolutions (mipmaps) and whenever something is either far away or viewed at a steep angle, switching to using lower resolution version of the textures.<br>
It help eliminate pixel shimmering and with high resolutions, can also improve performance (low resolution versions of textures can fit in GPU cache, allowing far away geometry to be drawn very quickly).</p>
<p>Default for mesh is &quot;off&quot;.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] texture anisotropic filtering (16 v) :: sensing
</div><p>Used for setting anisotropic filtering.<br>
1 is no anisotropic filtering.<br>
16 is maximum.<br>
<strong>It is not supported on all GPUs! Maximum value also varies depending on GPU.</strong><br>
Always setting it to 16, regardless of whether it is supported or what values are supported is still totally fine. Performance on underpowered devices that support it will no be fine though. So adding a toggle is a good idea.</p>
<p>Default for mesh 1.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] bone indices [listIndices v] weights [listWeights v] count per vertex (3) :: sensing
</div><p>Used for setting bone indices and weights.<br>
Count per vertex must be in range between 1 and 4.<br>
Indices start from 1.<br>
Weights are not used when count per vertex is 1.<br>
Length of supplied indices and weights lists have to match and be divisible by &quot;count per vertex&quot;.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] [original v] transforms [listTransforms v] :: sensing
set [my mesh] [current v] transforms [listTransforms v] :: sensing
</div><p>Used for setting original and current transforms of each bone.<br>
Transforms on how to get from original to current will be calculated and applied to vertices based on their bone indices and weights.<br>
Supplied list of transforms must have length divisible by 16. If not, operation fails.<br>
Setting original transforms is optional. Missing original transforms are treated as empty transforms.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] interleaved [XY positions v] [list v] :: sensing
</div><p>Used for setting vertex data. Does the same as those blocks:</p>
<div class="render-scratchblocks">set [my mesh] positions XY [listX v] [listY v] :: sensing
set [my mesh] positions XYZ [listX v] [listY v] [listZ v] :: sensing
set [my mesh] colors RGB [listR v] [listG v] [listB v] :: sensing
set [my mesh] colors RGBA [listR v] [listG v] [listB v] [listA v] :: sensing
set [my mesh] texture coordinates UV [listU v] [listV v] :: sensing
set [my mesh] texture coordinates UVW [listU v] [listV v] [listW v] :: sensing
</div><p>but from a single list with all the components interleaved.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] instance [transfroms v] [list v] :: sensing
</div><p>Used for setting data for instancing: drawing the same mesh many times (can be over a million) in multiple locations.</p>
<p>Only one in each of the following 3 catergories is allowed. Setting another one replaces the old one.</p>
<p>Positioning:</p>
<ul>
<li><code>transforms</code> - a list of transforms, with total length divisible by 16.</li>
<li><code>XY positions</code> - a list of interleaved X and Y positions, with total length divisible by 2.</li>
<li><code>XYZ positions</code> - a list of interleaved X, Y and Z positions, with total length divisible by 3.</li>
<li><code>XYZ positions and sizes</code> - a list of interleaved X, Y, Z positions and sizes, with total length divisible by 4.</li>
</ul>
<p>Colors:</p>
<ul>
<li><code>RGB colors</code> - a list of interleaved red, green and blue color components, with total length divisible by 3.</li>
<li><code>RGBA colors</code> - a list of interleaved red, green, blue and alpha color components, with total length divisible by 4.</li>
</ul>
<p>Texture coordinates:</p>
<ul>
<li><code>UV offsets</code> - a list of interleaved U and V texture coordinate offsets, with total length divisible by 2.</li>
<li><code>UV offsets and sizes</code> - a list of interleaved U, V texture coordinate offsets and U, V texture coordinate scaling factors, with total length divisible by 4.</li>
</ul>
<p>Setting positioning is required for instancing to activate.</p>
<p>All defined catergories have to have data for the same amount of instances. If the amount of instances inferred from the length of those lists do not match, mesh is not valid for drawing and cannot be drawn.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] list update offset (1) :: sensing
</div><p>Allows partially updating mesh data instead of fully reuploading.</p>
<p>Starts from 1.<br>
Having it set to 1 or above enables partial update mode.<br>
Having it set to 0 or below disables partial update mode and makes lists update fully.<br>
In partial update mode you can only update existing data. If your new data is too long and goes out of bounds of what is already set for the mesh, the operation will fail.<br>
<strong>If you accidentally enabled it and want to disable it, set it to 0, not 1!</strong><br>
That is because while both update list from the start, when you have it at 1, partial update mode is enabled and you cannot resize the data. If you try to upload more it will fail. If you try to upload less, the end will remain unchanged.</p>
<p><strong>This is one of 2 properties that is not inherited.</strong> This is done for performance reasons and to reduce chances of misuse.</p>
<p><strong>If you need to update data fully, do not use partial update mode at offset 1 to &quot;save memory&quot;. It only makes things worse.</strong> Only use it when you need to update only relatively a small section of data.</p>
<p>Default for mesh is 0.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] optimize next uploaded lists for being [rarely v] updated :: sensing
</div><p>Used for hinting GPU driver on how the data should be prepared. Different GPU drivers will handle it differently.</p>
<p>Usually you create mesh, set static data once, then toggle this to one of the frequent modes and start updating some that frequent data.<br>
If you suddenly need to update static data again, do not forget to temporarily switch it to &quot;rarely&quot;, before setting that data.</p>
<p>This only affects vertex related data. It does not affect uploading texture pixel data from a list.</p>
<p><strong>This is one of 2 properties that is not inherited.</strong> This is done for performance reasons and to reduce chances of misuse.</p>
<p>Deafult for mesh is &quot;rarely&quot;.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] from [obj mtl v] [list v] :: sensing
set [my mesh] from [off v] [list v] :: sensing
</div><p>Decodes a 3D model file and uploads it into a mesh. Block continues instantly, but the model loading is performed in a separate thread, and it finishes with a delay. Currently, only one thread is used, so everything is queued and processed one by one. In the future, multiple threads might be used.</p>
<p><strong>Note: This block is designed as a more of a shortcut for quick testing, rather than the main way of loading 3D models. For anything more complex make your own 3D model parser.</strong></p>
<p>File formats:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">obj</a> is a very common and well known 3D model file format. It supports UV texture coordinates, materials with colors and textures. However it does not have a standartized way to do vertex colors. This block implements a non-standart but widely supported way to represent vertex colors as 4th - 7th elements of <code>v</code>. The OBJ and MTL specification describes a lot of features, only some of which are currently (or even can be) supported by this importer. In particular, there is currently no way to import models which use multiple textures as this extensions only supports 1 texture per mesh. Normals and anything lighting related isn't and can't be supported. <strong>In case both OBJ and MTL files need to be imported, combine them all into 1 list sequentially, first all of the MTL files and then the OBJ file.</strong></li>
<li><a href="https://en.wikipedia.org/wiki/OFF_(file_format)">off</a> is a not that well known, but very simple file format. Is is quite neat for the use in scratch in general, as it's simpler than OBJ and unlike it, natively supports both vertex and face colors. It does not support textures or texture coordinates. You can read more about it and find a lot of example models <a href="http://web.archive.org/web/20230331211230/https://people.sc.fsu.edu/~jburkardt/data/off/off.html">here</a>.</li>
</ul>
<p>Imported model is affected by transformation set with:</p>
<div class="render-scratchblocks">configure [importing from file v] transformation :: sensing
</div><hr>
<div class="render-scratchblocks">set [my mesh] primitives (points v) :: sensing
</div><p>Used for changing the way vertices are assembled into primitives.</p>
<ul>
<li>With triangles, vertices are grouped by 3 into triangles.</li>
<li>With triangle strip, the first 2 vertices are processed without anything, and then each subsequent vertex get combined with the previous 2 into a triangle.</li>
<li>With triangle fan, the first 2 vertices are processed without anything, and then each subsequent vertex get combined with the previous one and the first one into a triangle.</li>
<li>With lines, vertices are grounded by 2 into lines.</li>
<li>With line strip, the first vertiex is processed without anything, and then each subsequent vertex get combined with the previous one into a line.</li>
<li>With line loop, the first vertiex is processed without anything, and then each subsequent vertex get combined with the previous one into a line and the last one gets also linked back to the first one.</li>
<li>With points, each vertex turns into a point.</li>
</ul>
<p>When using vertex indices, specifying vertex index 0 or below can be used to break up &quot;triangle strip&quot;, &quot;triangle fan&quot;, &quot;line strip&quot; and &quot;line loop&quot; into multiple ones.</p>
<p>Default for mesh is &quot;triangles&quot;.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] blending (default v) :: sensing
</div><p>Used for setting how mesh will be blender with what is already drawn.</p>
<p>If your mesh is fully opaque, use &quot;overwrite color (fastest for opaque)&quot;. If your mesh is transpartent instead, you can use it to draw transparent holes in an already opaque image.<br>
Use invisible for drawing to the depth buffer.<br>
Everything else is self-explanatory and the same as in <a href="https://extensions.turbowarp.org/Xeltalliv/clippingblending.js">Clipping &amp; Blending</a> extension.</p>
<p>Default for mesh is &quot;default&quot;.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] cull (back faces v) :: sensing
</div><p>Used for enabling/disabling backface/frontface culling. Basically making triangle visible only from one side, depening of whether their vertices appear on the screen in the clockwise or counter-clockwise order.</p>
<p>Deafult for mesh is &quot;nothing&quot;.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] discard pixels less opaque than (0.5), and for those that pass [make opaque v] :: sensing
</div><p>Used for disacrding pixels that are below specific opacity threshold and optionally making everything opaque.</p>
<p>Useful for drawing text or textures of leaves, where the texture itself should be either fully opaque or fully transparent, with texture alpha being used for determining where the sharp cutoff edges should be.</p>
<p>Default for mesh is threshold:0 preserve opacity.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] billboarding (on v) :: sensing
</div><p>Used for enabling and disabling billboarding.<br>
When billboarding is enabled, the mesh is always facing in the opposite direction to your look direction (behind you).<br>
Note that it is not the same as turning towards your position.</p>
<p>Default for mesh is &quot;off&quot;.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] accurate interpolation (on v) :: sensing
</div><p>(DEPRECTATED)<br>
Used for enabling a more accurate interpolation method which doesn't have issues of texture coordinates extrapolating outside of the specified range on the triangle edges, causing unpleasant looking seams. It is more computationally expensive and should only be used when that is an issue.<br>
Enabling mipmapping and/or anisatropic filtering may prevent it from working and reintroduce seams.</p>
<p>Default for mesh is &quot;off&quot;.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] compute color (once at pixel center v) :: sensing
</div><p>Replaces the deprectated &quot;accurate interpolation&quot; block.</p>
<p>Changes how color of each pixel is computed when MSAA antialiasing is enabled.</p>
<p>Sometimes it can be beneficial for visulas to make edges of rendered 3D graphics smoothed out instead of having sharply transitioning pixel colors. That is the problem that different antialiasing techniques are trying to slove. For now, in Simple3D extension MSAA antialiasing is always enabled for the main Simple3D layer, and always disabled when rendering to textures.</p>
<p>The simplest way to do antialiasing is called <a href="https://en.wikipedia.org/wiki/Supersampling">Supersampling</a> and consists of rendering the image at higher resoultion then what is needed and then downscaling it to lower resolution by averageing colors. It works, but it is quite slow.</p>
<p>A cheaper alternative to supersampling is a technique known as <a href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing">Multi-sample Antialiasing (MSAA)</a>. It still consists of rendering the image at higher resolution by giving each pixel multiple sub-pixels, however, the color for all the sub-pixels of a pixel is only computed once, usually based on position in the center of the pixel. At the end, the colors of all of the sub-pixels get averaged and the result is a rendered image with smooth edges. Sub-pixels are often referred as samples.</p>
<p>Unlike supersampling, MSAA only smoothes out primitive edges and not the sharp pixelated transitions on the primitive itself (e.g. textures).</p>
<ul>
<li>
<p><code>once at pixel center</code></p>
<p>This is a typical MSAA as described above.</p>
<p>It has an issue where if some of the samples on the edge of a pixel fall within the drawn primitive, but the center of a pixel doesn't, then the color will still be computed for the center of the pixel, causing passed in UV coordinates and vertex colors to be extrapolated beyond the specified range. It often results in visible texture seams casued by adjacent texture data bleeding into pixels that shouldn't have it or incorrect colors on edges.</p>
<p>Though, for most use cases this option is good enough with issue not being noticable. Since this is computationally the cheapest option, it is default.</p>
</li>
<li>
<p><code>once at midpoint of covered samples</code></p>
<p>This solves the issue described above by still computing color once, but instead of always doing it in the center of the pixel, which may not always fall within the primitive, it does it at the midpoint of all the samples that passed the inside-of-primitive check. Since all primitives are convex, this midpoint is also guaranteed to be within the primitive. This option is more computationally expensive, and as such, disabled by default.</p>
</li>
<li>
<p><code>separately for each sample</code></p>
<p>Computes color separately at each sample, turning this into Supersampling. This option relies on OES_shader_multisample_interpolation and as such isn't supported everywhere. It is also the most computationally expensive option.</p>
</li>
</ul>
<p>Note that enabling mipmapping and/or anisatropic filtering may reintroduce seams regardless of what was selected with this block.</p>
<p>Using <code>separately for each sample</code> with fallback to <code>once at midpoint of covered samples</code> can be implemented by calling the block twice. Selecting <code>separately for each sample</code> when it isn't supported will do nothing and keep the previous value.</p>
<p>Default for mesh is &quot;once at pixel center&quot;.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] vertex draw range from (1) to (6) :: sensing
</div><p>Used for drawing mesh partially by only drawing some range of the vertices.</p>
<p>Could be useful in cases where the mesh keeps changing (including amount of vertices and primitives).<br>
For cases like that, prepare a lot of dummy vertex data in advance. Then only fill and start drawing the beginning of it.<br>
Use partial updates to add any extra polygons after the range that is being drawn and then extend the range to include them.<br>
To remove polygons, move the ones from the end of the drawing range to location of the remove one and then shring the drawing<br>
range at the end.</p>
<p>Default for mesh is not set. Once set, cannot be undone.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] instance draw limit (10) :: sensing
</div><p>Normally, how many instances are drawn is determined by the length of supplied lists.<br>
This block can be used to limit the amount of instances drawn to an even lower number.<br>
This can be useful together with partial list updates to be able to dynamically change amount of drawn instances without having to reupload the entire list. That is, preallocating space for some amount of instances in advance, but drawing less. When new instance needs to be added, using partial updates to update the instance data of the next unused instance and then increasing the limit by 1. To remove an instance, the last instance can be moved in it's place and then the limit reduced by 1.</p>
<p>Setting to any value below 1 is equivalent to setting it to Infinity.</p>
<p>Default for mesh is Infinity.</p>
<hr>
<div class="render-scratchblocks">set [my mesh] texture coordinate offset UV (0) (0) :: sensing
</div><p>Used for offsetting texture UVs.<br>
Combined with textures with &quot;repeat&quot; mode and timer block, this can be used to very easily create meshes with scrolling textures.</p>
<p>Default for mesh is 0,0.</p>
<hr>
<div class="render-scratchblocks">draw mesh [my mesh] :: sensing
</div><p>Draws the specified mesh one or multiple (instancing) times, but only if it is valid.</p>
<p>Mesh is invalid and cannot be drawn if:</p>
<ul>
<li>vertex positions are not set</li>
<li>lists that were uploaded to it imply mismatching amounts of vertices or instances</li>
</ul>
<p>This block may cause stutter when drawing something for the first time, as it will need to generate and compile shaders.</p>
<h3>Textures <a name="blocks-textures"></a></h3>
<div class="render-scratchblocks">(texture from URL [https://extensions.turbowarp.org/dango.png] :: sensing)
</div><p>Creates texture from image at specified URL.<br>
Will show a prompt if URL is not approved.<br>
If an image fails to load, you can usually open browser console and see what the error is. (F12 or Ctrl+Shift+I)<br>
<strong>Note that websites cannot access any data from any other websites unless those other sites explicetly allow it. The correct term for it is CORS (Cross Origin Resource Sharing). You can use some CORS proxy to bypass it.</strong><br>
🐢 Texture gets loaded with a delay.</p>
<hr>
<div class="render-scratchblocks">(texture from costume [costume1 v] :: sensing)
</div><p>Creates texture from costume.<br>
🐢 <strong>Texture gets loaded with a delay. When doing image processing, do not attempt to load and instantly draw. It would not show up!</strong></p>
<p><strong>Do not forget: bitmap costumes have 2x2 subpixels, which here are counted as pixels.</strong> So do not be surprized when your seemingly 8x8 costume turns into 16x16 texture.</p>
<p><strong>When using TurboWarp Packager, you need to disable &quot;Remove raw asset data after loading to save RAM&quot; in order for this block to work.</strong></p>
<hr>
<div class="render-scratchblocks">(texture from text [Hello World!] font [italic bold 32px sans-serif] color (#ffff00) :: sensing)
(texture from text [Hello World!] font [italic bold 32px sans-serif] color (#ffff00) border (5) (#000000) :: sensing)
</div><p>Creates texture with specified text.<br>
⚡ Texture gets loaded instantly.<br>
Border extends texture by it's value of pixels in all 4 directions.<br>
For more information on the font argument syntax, see <a href="https://drafts.csswg.org/css-fonts/#font-prop">CSS Specification</a>.</p>
<hr>
<div class="render-scratchblocks">(texture from list [list v] at (1) of size (16) (16) :: sensing)
</div><p>Creates texture from RGBA data in a list. Each pixel is represented with list 4 elements, each in range between 0 and 255. Elements are: red, green, blue, alpha.<br>
Note that it is not alpha, red, green, blue used by many pen projects on scratch.<br>
⚡ Texture gets loaded instantly.</p>
<hr>
<div class="render-scratchblocks">(texture of size (16) (16) :: sensing)
</div><p>Creates black texture of given size.<br>
⚡ Texture gets loaded instantly.</p>
<h3>Text measurement <a name="blocks-text-measurement"></a></h3>
<div class="render-scratchblocks">measure text [Hello World!] font [italic bold 32px sans-serif] :: sensing
(measured (up v) size ::sensing)
</div><p>Used for measuring how the text texture was or will be generated.<br>
Outputs 4 sizes. Sizes can be negative.</p>
<h3>Fonts <a name="blocks-fonts"></a></h3>
<div class="render-scratchblocks">(font [Sans Serif] of size [32] :: sensing)
</div><p>Used for getting internal names of default and custom fonts. It is not neccesary to use.</p>
<h3>View transformations <a name="blocks-view-transformations"></a></h3>
<div class="render-scratchblocks">configure [to projected from view space v] transformation :: sensing
</div><p>Used for switching between which of the few transformations is currently active for editing.<br>
Transformations <code>to world space from model space</code>, <code>to view space from world space</code>, <code>to projected from view space</code> are 3 sequential transformation used for drawing, explained at the top of this page.<br>
Transformation <code>importing from file</code> affects how the block below works:</p>
<div class="render-scratchblocks">set [my mesh] from [.obj .mtl v] [list v] :: sensing
</div><p>Transformation <code>custom</code> does not affect anything. Use it for your own calculations.</p>
<hr>
<div class="render-scratchblocks">start with perspective FOV (90) near (0.1) far (1000) :: sensing
</div><p>Overwrites currently active transformation with the viewspace to clipspace conversion transformation for perspective projection.<br>
<strong>Camera is assumed to be facing negative Z.</strong><br>
FOV is verical field of view and it is measured in degrees.<br>
Anything closer than &quot;near&quot; or further than &quot;far&quot; will be clipped.</p>
<p>Something to keep in mind is that depth buffer has limited precision.<br>
The whole range between &quot;near&quot; and &quot;far&quot; get mapped to the whole range of depth buffer.<br>
So, setting near and far to be close to one another makes depth more precise.<br>
Setting near and far to vastly different value will cause Z-fighting issues caused by lack of precision.</p>
<p><strong>Another thing to keep in mind is that this block requires aspect ratio.</strong> To not bother it's users, it was decided to make it take aspect ratio of the currently active rendering target. Most projects do not change aspect ratio while running, but if you plan to support that, recalculate this every time after getting:</p>
<div class="render-scratchblocks">when resolution changes :: sensing hat
</div><hr>
<div class="render-scratchblocks">start with orthographic near (0.1) far (1000) :: sensing
</div><p>Overwrites currently active transformation with the viewspace to clipspace conversion transformation for orthographic projection.<br>
<strong>Camera is assumed to be facing negative Z.</strong><br>
Same regarding &quot;near&quot;, &quot;far&quot;, and aspect ratios as the block described above.</p>
<hr>
<div class="render-scratchblocks">start with no transformation :: sensing
</div><p>Overwrites currently active transformation with transformation that does nothing and keeps everything as is.</p>
<hr>
<div class="render-scratchblocks">start with [external source v] :: sensing
</div><p>Overwrites currently active transformation with transformation obtained from the external source. Hidden by default. External sources can be provided by other extensions.</p>
<hr>
<div class="render-scratchblocks">start with saved in [list v] at (1) :: sensing
</div><p>Overwrites currently active transformation with transformation from the list. Reads 16 values starting from the index specified by the second argument.</p>
<hr>
<div class="render-scratchblocks">move X (0) Y (0) Z (0) :: sensing
rotate around [X v] by (0) degrees :: sensing
scale X (1) Y (1) Z (1) :: sensing
</div><p>Applies change to currently selected transformation</p>
<hr>
<div class="render-scratchblocks">wrapper {
} :: sensing
</div><p>Saves all 5 transformations (not just currently selected) when entering, restores when exiting. For technical reasons does not currently restore, if the script inside called:</p>
<div class="render-scratchblocks">stop [this script v]
</div><p><strong>Also has 1 frame delay to exit, because it is technically treated as a loop. And similarly to loops, you can use <code>run without screen refresh</code> custom blocks to remove the delay.</strong></p>
<hr>
<div class="render-scratchblocks">save into [list v] at (1) :: sensing
</div><p>Overwites 16 elements in list starting from the specified item, with the numbers representing currently selected transformation.</p>
<hr>
<div class="render-scratchblocks">reset transformation's (offset v) :: sensing
</div><p>Resets offset or rotation of the transformation.</p>
<p>Rotation without offset can be useful for transforming directions or drawing skyboxes.<br>
Offset without rotation can be useful for positioning something at the end of the long chain of transformations, but rotating it independently afterwards relatively to the world.</p>
<h3>Manual transformations <a name="blocks-manual-transformations"></a></h3>
<div class="render-scratchblocks">transform X (0) Y (0) Z (0) :: sensing
</div><p>Transforms point using currently selected transformation. It is the fastest way to transform coordinates, especially if there are a lot of them.</p>
<hr>
<div class="render-scratchblocks">transform X (0) Y (0) Z (0) from [world space v] to [model space v] :: sensing
transform direction X (0) Y (0) Z (0) from [world space v] to [model space v] :: sensing
</div><p>Transforms point from specified coordinate system to another. Convenient, but slower.<br>
Transform direction only applies rotations and does not apply offsets.</p>
<p>&quot;projected&quot; is pre-division clip-space coordinates.<br>
&quot;projected (scratch units)&quot; does division by W and scaling to current stage size (e.g. 480x360). It can be used to determine where some point will end up on the screen with the current transformation to position sprite over it or draw something with pen.</p>
<h3>Rendering into textures <a name="blocks-rendertargets"></a></h3>
<div class="render-scratchblocks">render to stage :: sensing
</div><p>Selects simple3D layer as an active render target.</p>
<hr>
<div class="render-scratchblocks">render to texture of [my mesh] :: sensing
</div><p>Selects 2D texture of specified mesh as an active render target.<br>
Fails if there is no texture or texture is not 2D.</p>
<hr>
<div class="render-scratchblocks">render to cube texture (X+ v) of [my mesh] :: sensing
</div><p>Selects side of cube texture of specified mesh as an active render target.<br>
Fails if there is no texture, texture is not cube or side is not valid.</p>
<hr>
<div class="render-scratchblocks">read current render target into [list v] :: sensing
</div><p>Reads the pixel data of the current render target into the list.<br>
There are 4 values per pixels: red, greeen, blue, alpha.<br>
Values should be in range between 0 and 255.</p>
<p>Internally extension stores everything with premultiplied alpha. When reading this, it divides by alpha to restore directly respreseted colors.</p>
<hr>
<div class="render-scratchblocks">(render target [width v] :: sensing)
</div><p>Allows reading properties of the current render target.</p>
<hr>
<div class="render-scratchblocks">set [viewport box v] to X1:(0) Y1:(0) X2:(100) Y2:(100) :: sensing
set [clipping box v] to X1:(0) Y1:(0) X2:(100) Y2:(100) :: sensing
set [readback box v] to X1:(0) Y1:(0) X2:(100) Y2:(100) :: sensing
</div><p>Configures custom rectangular areas for different purposes for the currently active render target.<br>
Viewport box specifies the area to which the rendered image will be stretched to cover from it's normal -1 to 1 range.<br>
Clipping box specifies the area in which pixels are allowed to be modified.<br>
Readback box specifies the area from which reading to list and reading to data URI blocks will read the pixels.</p>
<p>Note: coordinates are specified in <strong>real pixels</strong> starting from the bottom left corner, <strong>not scratch units</strong>. You can get the size of the Simple3D layer in pixels from either:</p>
<div class="render-scratchblocks">(stage width :: sensing)
(stage height :: sensing)

(render target [width v] :: sensing)
(render target [height v] :: sensing)
</div><p>And while it may match scratch units while the high quality pen is disabled, when <strong>high quality pen is on</strong>, the resolution will often be higher. Your projects need to account for that.</p>
<p>Note: Those custom areas can either be set or not set. When they aren't set, they use X1:<code>0</code> Y1:<code>0</code> X2:<code>render target width</code> Y2:<code>render target height</code> and automatically update with resolution changes. If you set them to custom values, you need to handle rescaling manually.</p>
<hr>
<div class="render-scratchblocks">clear [viewport box v] :: sensing
clear [clipping box v] :: sensing
clear [readback box v] :: sensing
</div><p>Removes the custom rectangular areas configured by the block described above.</p>
<h3>Tinting and fog <a name="blocks-tinting-fog"></a></h3>
<div class="render-scratchblocks">set global color [multiplier v] to R: (1) G:(1) B:(1) A:(1) :: sensing
set global color [adder v] to R: (0) G:(0) B:(0) A:(0) :: sensing
</div><p>Allows setting up linear transformation to color.<br>
Input color RGBA is multiplied by &quot;multiplier&quot; and then the &quot;adder&quot; values are added.<br>
Here 0 is fully dark and 1 is full brightness. Values above 1 or below 0 will get clamped.<br>
This is a global value. It is okay to change it many times per frame.</p>
<p>Deafult multiplier is R:1 G:1 B:1 A:1.<br>
Deafult adder is R:0 G:0 B:0 A:0.</p>
<hr>
<div class="render-scratchblocks">turn fog (on v) :: sensing
</div><p>Used for toggling fog on or off. Accepts a boolean argument (true or false).<br>
This is a global value. It is okay to change it many times per frame.<br>
Default is off.</p>
<hr>
<div class="render-scratchblocks">set fog color R:(1) G:(1) B:(1) :: sensing
</div><p>Sets fog color.<br>
Default is R:1 G:1 B:1.</p>
<hr>
<div class="render-scratchblocks">set fog distance near: (10) far: (100) :: sensing
</div><p>Sets fog distance.<br>
<code>Near</code> sets the distance at which mesh starts transition into the fog color.<br>
<code>Far</code> sets the distance at which mesh fully finishes transitioning into the fog color.</p>
<p>Setting <code>near</code> to value greater than <code>far</code> results is a fog that starts close, and fades off with a distance.<br>
Setting both arguments to the same value results in division by 0 and leads to undefined results, so avoid doing it.</p>
<p>Default is near:10 far:100.</p>
<hr>
<div class="render-scratchblocks">set fog [view space v] origin at X: (0) Y: (0) Z: (0) :: sensing
</div><p>Specifies the center point around which the fog will be drawn.<br>
Default is X:0 Y:0 Z:0 in view space.</p>
<h3>Resolution changes <a name="blocks-resolution"></a></h3>
<div class="render-scratchblocks">when resultion changes :: sensing hat
(stage width :: sensing)
(stage height :: sensing)
</div><p>simple3D layer automatically always matches the resolution of the pen layer (or what resolution pen layer would have if it was present, even when pen layer is missing).<br>
That means that by default, at default stage size it is locked to 480x360, but with &quot;High quality pen&quot; enabled or non-default stage sizes, it can become something different.<br>
Hat block gets triggered when that resoltion changes.<br>
Reporter blocks report current resolution.</p>
<p>Technically those blocks could be workarounded by contantly checking with blocks listed below.</p>
<div class="render-scratchblocks">render to stage :: sensing
(render target [width v] :: sensing)
(render target [height v] :: sensing)
</div><h2>Integrations with other extensions <a name="ext-integration"></a></h2>
<p>Simple 3D can have integrations with other extensions. If you are an extension developer, see <code>Scratch.vm.runtime.ext_xeltallivSimple3Dapi</code> for that.</p>
<h3>Augmented Reality extension <a name="ar-integration"></a></h3>
<p>While it is possible to upload all 16 components from matrices provided by Augmented Reality extension into transforms of this extension,</p>
<div class="render-scratchblocks">configure [to projected from view space v] transformation :: sensing
set [i v] to (0)
repeat (16)
change [i v] by (1)
replace item (i) of [list v] with (item (i) of [projection v] matrix :: #d10000)
end
start with saved in [list v] at (0) :: sensing
</div><p>to make this process easier, an extra feature was added.</p>
<p>When Simple 3D extension and Augmented Reality extension are present in the project at the same time, users get access to the following extra blocks:</p>
<div class="render-scratchblocks">start with (AR: combined v) :: sensing
start with (AR: view to projected v) :: sensing
start with (AR: view to world v) :: sensing
start with (AR: world to view v) :: sensing
</div><p>Those blocks copy values from AR extension identically to the repeat loop example above, but do it in 1 block.<br>
An example of a simple 3D project using both extension is shown below: <a name="ar-example"></a></p>
<div class="render-scratchblocks">when flag clicked
enter AR mode :: #d10000
create mesh [my mesh] :: sensing
set [my mesh] from [obj mtl v] [my 3D model v] :: sensing
forever
configure [to projected from view space v] transformation :: sensing
start with (AR: view to projected v) :: sensing
configure [to view space from world space v] transformation :: sensing
start with (AR: world to view v) :: sensing
clear [color and depth v] :: sensing
draw mesh [my mesh] :: sensing
end

when stage clicked
move everything by x: (hit position [x v] :: #d10000) y: (hit position [y v] :: #d10000) z: (hit position [z v] :: #d10000) :: #d10000
</div>

      <hr>

      <footer>
        <p>
          This page is <a href="https://github.com/TurboWarp/extensions/tree/master/docs">open source</a>.
          
            Blocks rendered with <a href="https://scratchblocks.github.io/">scratchblocks</a>.
          
        </p>
        <p>TurboWarp is not affiliated with Scratch, the Scratch Team, or the Scratch Foundation.</p>
      </footer>
    </main>

    
      <script src="/docs-internal/scratchblocks.js"></script>
      <script>
        scratchblocks.renderMatching('.render-scratchblocks', {
          style: 'scratch3'
        });
      </script>
    
  </body>
</html>
