// Name: Sound Expanded
// Description: Adds more sound-related blocks.
// ID: lmsSoundExpanded
// By: LilyMakesThings <https://scratch.mit.edu/users/LilyMakesThings/>
// License: MIT AND LGPL-3.0

/* generated l10n code */Scratch.translate.setup({"de":{"_Sound Expanded":"Klänge Erweitert"},"fi":{"_Sound Expanded":"Laajennettu ääni","_[ATTRIBUTE] of [SOUND]":"äänen [SOUND] [ATTRIBUTE]","_[SOUND] is looping?":"soitetaanko ääntä [SOUND] silmukassa?","_change project volume by [VALUE]":"lisää projektin äänenvoimakkuutta arvolla [VALUE]","_channels":"kanavat","_effect [EFFECT] of [TARGET]":"hahmon [TARGET] tehoste [EFFECT]","_end looping [SOUND]":"älä soita ääntä [SOUND] silmukassa","_length":"pituus","_pan":"panoroi vasen/oikea","_pause all sounds":"keskeytä kaikki äänet","_pitch":"sävelkorkeus","_play sound [SOUND] from [START] seconds until done":"soita ääni [SOUND] [START] s:n kohdalta loppuun","_play sound [SOUND] from [START] to [END] seconds until done":"soita ääni [SOUND] [START] – [END] s:n alueelta loppuun","_project volume":"projektin äänenvoimakkuus","_resume all sounds":"jatka kaikkia ääniä","_sample rate":"näytteenottotaajuus","_set project volume to [VALUE]%":"aseta projektin äänenvoimakkuudeksi [VALUE] %","_sound [SOUND] is playing?":"soitetaanko ääntä [SOUND]?","_start looping [SOUND]":"soita [SOUND] silmukassa","_start looping [SOUND] loop region [START] to [END] seconds":"soita [SOUND] silmukassa [START] – [END] s:n alueelta","_start looping [SOUND] loop start [START] seconds":"soita [SOUND] silmukassa aloittaen [START] s:n kohdalta","_start sound [SOUND] from [START] seconds":"soita ääni [SOUND] [START] s:n kohdalta","_start sound [SOUND] from [START] to [END] seconds":"soita ääni [SOUND] [START] – [END] s:n alueelta","_stop sound [SOUND]":"pysäytä ääni [SOUND]"},"it":{"_Sound Expanded":"Suoni Plus"},"ja":{"_Sound Expanded":"サウンド拡張","_[ATTRIBUTE] of [SOUND]":"[SOUND]の[ATTRIBUTE]","_[SOUND] is looping?":"[SOUND]がループしている","_change project volume by [VALUE]":"プロジェクトの音量を[VALUE]ずつ変える","_channels":"チャンネル数","_dataURI":"データURL","_effect [EFFECT] of [TARGET]":"[TARGET]の[EFFECT]の効果量","_end looping [SOUND]":"[SOUND]のループを止める","_length":"長さ","_pan":"パン","_pause all sounds":"すべての音を一時停止する","_pitch":"ピッチ","_play sound [SOUND] from [START] seconds until done":"終わるまで[SOUND]の音を[START]秒から鳴らす","_play sound [SOUND] from [START] to [END] seconds until done":"終わるまで[SOUND]の音を[START]秒から[END]秒まで鳴らす","_project volume":"プロジェクトの音量","_resume all sounds":"すべての音を再開する","_sample rate":"サンプルレート","_set project volume to [VALUE]%":"プロジェクトの音量を[VALUE]%にする","_sound [SOUND] is playing?":"[SOUND]が再生中","_start looping [SOUND]":"[SOUND]をループ再生する","_start looping [SOUND] loop region [START] to [END] seconds":"[SOUND]のループを[START]秒から[END]秒の範囲で行う","_start looping [SOUND] loop start [START] seconds":"[SOUND]のループを[START]秒から行う","_start sound [SOUND] from [START] seconds":"[SOUND]の音を[START]秒から鳴らす","_start sound [SOUND] from [START] to [END] seconds":"[SOUND]の音を[START]秒から[END]秒まで鳴らす","_stop sound [SOUND]":"[SOUND]の音を止める"},"ko":{"_Sound Expanded":"소리 확장","_[ATTRIBUTE] of [SOUND]":"[SOUND]의 [ATTRIBUTE]","_[SOUND] is looping?":"[SOUND]이(가) 반복 재생인가?","_change project volume by [VALUE]":"프로젝트의 음량을 [VALUE]만큼 바꾸기 ","_channels":"채널 수","_effect [EFFECT] of [TARGET]":"[TARGET]의 [EFFECT]효과","_end looping [SOUND]":"[SOUND] 반복 멈추기","_length":"재생 길이","_pan":"소리 좌우 위치","_pause all sounds":"모든 소리 일시정지하기","_pitch":"음 높이","_play sound [SOUND] from [START] seconds until done":"소리 [SOUND]을(를) [START]초부터 끝까지 재생하기","_play sound [SOUND] from [START] to [END] seconds until done":"소리 [SOUND]을(를) [START]초부터 끝나기 [END]초 전까지 재생하기","_project volume":"프로젝트의 음량","_resume all sounds":"모든 소리 재시작하기","_sample rate":"샘플레이트","_set project volume to [VALUE]%":"프로젝트의 음량을 [VALUE]% 로 정하기","_sound [SOUND] is playing?":"소리 [SOUND]이(가) 재생 중인가?","_start looping [SOUND]":"[SOUND] 반복 재생하기","_start looping [SOUND] loop region [START] to [END] seconds":"소리 [SOUND]을(를) [START]초부터 [END]초까지의 구간에서 반복 재생하기 ","_start sound [SOUND] from [START] to [END] seconds":"소리 [SOUND]을(를) [START]초부터 [END]초까지 재생하기","_stop sound [SOUND]":"소리 [SOUND] 끄기"},"nb":{"_Sound Expanded":"Lyd Utvidet"},"nl":{"_Sound Expanded":"Geluid+","_[ATTRIBUTE] of [SOUND]":"[ATTRIBUTE] van [SOUND]","_[SOUND] is looping?":"[SOUND] is aan het herhalen?","_change project volume by [VALUE]":"verander projectvolume met [VALUE]","_channels":"kanalen","_effect [EFFECT] of [TARGET]":"effect [EFFECT] van [TARGET]","_end looping [SOUND]":"stop met herhalen van [SOUND]","_length":"lengte","_pan":"kanaal links/rechts","_pause all sounds":"pauzeer alle geluiden","_pitch":"toonhoogte","_play sound [SOUND] from [START] seconds until done":"start geluid [SOUND] vanaf [START] seconden en wacht","_play sound [SOUND] from [START] to [END] seconds until done":"start geluid [SOUND] vanaf [START] tot [END] seconden en wacht","_project volume":"projectvolume","_resume all sounds":"hervat alle geluiden","_sample rate":"bemonsteringsfrequentie (sample rate)","_set project volume to [VALUE]%":"zet projectvolume op [VALUE]%","_sound [SOUND] is playing?":"[SOUND] is aan het spelen?","_start looping [SOUND]":"herhaal [SOUND]","_start looping [SOUND] loop region [START] to [END] seconds":"herhaal [SOUND] met herhaalregio [START] tot [END] seconden","_start looping [SOUND] loop start [START] seconds":"herhaal [SOUND] met herhaalbegin [START] seconden","_start sound [SOUND] from [START] seconds":"start geluid [SOUND] vanaf [START] seconden","_start sound [SOUND] from [START] to [END] seconds":"start geluid [SOUND] vanaf [START] tot [END] seconden","_stop sound [SOUND]":"stop geluid [SOUND]"},"ru":{"_Sound Expanded":"Расширенный Звук","_[ATTRIBUTE] of [SOUND]":"[ATTRIBUTE] звука [SOUND]","_[SOUND] is looping?":"[SOUND] повторяется?","_change project volume by [VALUE]":"изменить звук проекта на [VALUE]","_channels":"каналы","_dataURI":"Хранилище Данных","_effect [EFFECT] of [TARGET]":"эффект [EFFECT] цели [TARGET]","_end looping [SOUND]":"закончить повторение [SOUND]","_length":"длина","_pan":"Пан","_pause all sounds":"приостановить все звуки","_pitch":"Высота","_play sound [SOUND] from [START] seconds until done":"играть звук [SOUND] с [START] секунд и ждать","_play sound [SOUND] from [START] to [END] seconds until done":"играть звук [SOUND] с [START] до [END] секунд и ждать","_project volume":"звук проекта","_resume all sounds":"продолжить все звуки","_sample rate":"частота дискретизации","_set project volume to [VALUE]%":"задать звук проекта на [VALUE]%","_sound [SOUND] is playing?":"звук [SOUND] играет?","_start looping [SOUND]":"начать повторять [SOUND]","_start looping [SOUND] loop region [START] to [END] seconds":"начать повторять [SOUND] регион повторения [START] к [END] секундам","_start looping [SOUND] loop start [START] seconds":"начать повторять [SOUND] и начать с [START] секунд","_start sound [SOUND] from [START] seconds":"начать звук [SOUND] с [START] секунд","_start sound [SOUND] from [START] to [END] seconds":"начать звук [SOUND] с [START] до [END] секунд","_stop sound [SOUND]":"остановить звук [SOUND]"},"tr":{"_Sound Expanded":"Genişletilmiş Ses"},"uk":{"_Sound Expanded":"Звук+"},"zh-cn":{"_Sound Expanded":"声音积木扩展","_[ATTRIBUTE] of [SOUND]":"[SOUND]的[ATTRIBUTE]","_[SOUND] is looping?":"[SOUND]正在循环播放？","_change project volume by [VALUE]":"将作品音量增加[VALUE]","_channels":"声道数","_dataURI":"dataURL","_effect [EFFECT] of [TARGET]":"[TARGET]的音效[EFFECT]","_end looping [SOUND]":"停止循环播放[SOUND]","_length":"时长","_pan":"左右平衡","_pause all sounds":"暂停所有声音","_pitch":"音调","_play sound [SOUND] from [START] seconds until done":"从第[START]秒开始播放[SOUND]直到结束","_play sound [SOUND] from [START] to [END] seconds until done":"播放[SOUND]的第[START]到[END]秒直到结束","_project volume":"作品音量","_resume all sounds":"继续所有声音","_sample rate":"采样率","_set project volume to [VALUE]%":"将作品音量设为[VALUE]%","_sound [SOUND] is playing?":"声音[SOUND]正在播放？","_start looping [SOUND]":"循环播放[SOUND]","_start looping [SOUND] loop region [START] to [END] seconds":"循环播放[SOUND]的第[START]到[END]秒","_start looping [SOUND] loop start [START] seconds":"从第[START]秒开始循环播放[SOUND]","_start sound [SOUND] from [START] seconds":"从第[START]秒开始播放[SOUND]","_start sound [SOUND] from [START] to [END] seconds":"播放[SOUND]的第[START]到[END]秒","_stop sound [SOUND]":"停止播放[SOUND]"}});/* end generated l10n code */(function (Scratch) {
  "use strict";

  const vm = Scratch.vm;
  const runtime = vm.runtime;
  const soundCategory = runtime.ext_scratch3_sound;

  class SoundExpanded {
    getInfo() {
      return {
        id: "lmsSoundExpanded",
        color1: "#CF63CF",
        color2: "#C94FC9",
        color3: "#BD42BD",
        name: Scratch.translate("Sound Expanded"),
        blocks: [
          {
            opcode: "startLooping",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("start looping [SOUND]"),
            arguments: {
              SOUND: {
                type: Scratch.ArgumentType.SOUND,
              },
            },
            extensions: ["colours_sounds"],
          },
          {
            opcode: "startLoopingBegin",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate(
              "start looping [SOUND] loop start [START] seconds"
            ),
            arguments: {
              SOUND: {
                type: Scratch.ArgumentType.SOUND,
              },
              START: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: "2",
              },
            },
            extensions: ["colours_sounds"],
          },
          {
            opcode: "startLoopingBeginEnd",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate(
              "start looping [SOUND] loop region [START] to [END] seconds"
            ),
            arguments: {
              SOUND: {
                type: Scratch.ArgumentType.SOUND,
              },
              START: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: "2",
              },
              END: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: "4",
              },
            },
            extensions: ["colours_sounds"],
          },
          {
            opcode: "stopLooping",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("end looping [SOUND]"),
            arguments: {
              SOUND: {
                type: Scratch.ArgumentType.SOUND,
              },
            },
            extensions: ["colours_sounds"],
          },
          {
            opcode: "isLooping",
            blockType: Scratch.BlockType.BOOLEAN,
            text: Scratch.translate("[SOUND] is looping?"),
            arguments: {
              SOUND: {
                type: Scratch.ArgumentType.SOUND,
              },
            },
            extensions: ["colours_sounds"],
          },

          "---",

          {
            opcode: "playSoundAtAndWait",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate(
              "play sound [SOUND] from [START] seconds until done"
            ),
            arguments: {
              SOUND: {
                type: Scratch.ArgumentType.SOUND,
              },
              START: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: "2",
              },
            },
            extensions: ["colours_sounds"],
          },
          {
            opcode: "playSoundAt",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("start sound [SOUND] from [START] seconds"),
            arguments: {
              SOUND: {
                type: Scratch.ArgumentType.SOUND,
              },
              START: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: "2",
              },
            },
            extensions: ["colours_sounds"],
          },
          {
            opcode: "playSoundToAndWait",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate(
              "play sound [SOUND] from [START] to [END] seconds until done"
            ),
            arguments: {
              SOUND: {
                type: Scratch.ArgumentType.SOUND,
              },
              START: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: "2",
              },
              END: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: "4",
              },
            },
            extensions: ["colours_sounds"],
          },
          {
            opcode: "playSoundTo",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate(
              "start sound [SOUND] from [START] to [END] seconds"
            ),
            arguments: {
              SOUND: {
                type: Scratch.ArgumentType.SOUND,
              },
              START: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: "2",
              },
              END: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: "4",
              },
            },
            extensions: ["colours_sounds"],
          },
          {
            opcode: "stopSound",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("stop sound [SOUND]"),
            arguments: {
              SOUND: {
                type: Scratch.ArgumentType.SOUND,
              },
            },
            extensions: ["colours_sounds"],
          },
          {
            opcode: "pauseSounds",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("pause all sounds"),
            arguments: {
              SOUND: {
                type: Scratch.ArgumentType.SOUND,
              },
            },
            extensions: ["colours_sounds"],
          },
          {
            opcode: "resumeSounds",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("resume all sounds"),
            arguments: {
              SOUND: {
                type: Scratch.ArgumentType.SOUND,
              },
            },
            extensions: ["colours_sounds"],
          },

          "---",

          {
            opcode: "isSoundPlaying",
            blockType: Scratch.BlockType.BOOLEAN,
            text: Scratch.translate("sound [SOUND] is playing?"),
            arguments: {
              SOUND: {
                type: Scratch.ArgumentType.SOUND,
              },
            },
            extensions: ["colours_sounds"],
          },
          {
            opcode: "attributeOfSound",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("[ATTRIBUTE] of [SOUND]"),
            arguments: {
              ATTRIBUTE: {
                type: Scratch.ArgumentType.STRING,
                menu: "attribute",
              },
              SOUND: {
                type: Scratch.ArgumentType.SOUND,
              },
            },
            extensions: ["colours_sounds"],
          },
          {
            opcode: "getSoundEffect",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("effect [EFFECT] of [TARGET]"),
            arguments: {
              EFFECT: {
                type: Scratch.ArgumentType.STRING,
                menu: "effect",
              },
              TARGET: {
                type: Scratch.ArgumentType.STRING,
                menu: "targets",
              },
            },
            extensions: ["colours_sounds"],
          },
          "---",
          {
            opcode: "setProjectVolume",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("set project volume to [VALUE]%"),
            arguments: {
              VALUE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 100,
              },
            },
            extensions: ["colours_sounds"],
          },
          {
            opcode: "changeProjectVolume",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("change project volume by [VALUE]"),
            arguments: {
              VALUE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: -10,
              },
            },
            extensions: ["colours_sounds"],
          },
          {
            opcode: "getProjectVolume",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("project volume"),
            extensions: ["colours_sounds"],
          },
        ],
        menus: {
          attribute: {
            acceptReporters: false,
            items: [
              {
                text: Scratch.translate("length"),
                value: "length",
              },
              {
                text: Scratch.translate("channels"),
                value: "channels",
              },
              {
                text: Scratch.translate("sample rate"),
                value: "sample rate",
              },
              {
                text: Scratch.translate("dataURI"),
                value: "dataURI",
              },
            ],
          },
          effect: {
            acceptReporters: false,
            items: [
              {
                text: Scratch.translate("pitch"),
                value: "pitch",
              },
              {
                text: Scratch.translate("pan"),
                value: "pan",
              },
            ],
          },
          targets: {
            acceptReporters: true,
            items: "_getTargets",
          },
        },
      };
    }

    _startLooping(util, sound, loopStart, loopEnd) {
      const index = this._getSoundIndex(sound, util);
      if (index < 0) return;

      const target = util.target;
      const sprite = util.target.sprite;

      const soundId = sprite.sounds[index].soundId;
      const soundPlayer = sprite.soundBank.soundPlayers[soundId];

      if (!soundPlayer.isPlaying) {
        soundCategory._addWaitingSound(target.id, soundId);
        sprite.soundBank.playSound(util.target, soundId);
      }

      if (!soundPlayer.outputNode) return;

      soundPlayer.outputNode.loop = true;
      soundPlayer.outputNode.loopStart = loopStart;
      // If loopEnd is the default of 0, then loopStart is ignored
      soundPlayer.outputNode.loopEnd =
        loopEnd || soundPlayer.outputNode.buffer.duration;
    }

    startLooping(args, util) {
      this._startLooping(util, args.SOUND, 0, 0);
    }

    startLoopingBegin(args, util) {
      this._startLooping(
        util,
        args.SOUND,
        Scratch.Cast.toNumber(args.START),
        0
      );
    }

    startLoopingBeginEnd(args, util) {
      this._startLooping(
        util,
        args.SOUND,
        Scratch.Cast.toNumber(args.START),
        Scratch.Cast.toNumber(args.END)
      );
    }

    stopLooping(args, util) {
      const index = this._getSoundIndex(args.SOUND, util);
      if (index < 0) return false;
      const sprite = util.target.sprite;

      const soundId = sprite.sounds[index].soundId;
      const soundPlayer = sprite.soundBank.soundPlayers[soundId];

      if (!soundPlayer.outputNode) return;
      soundPlayer.outputNode.loop = false;
    }

    isLooping(args, util) {
      const index = this._getSoundIndex(args.SOUND, util);
      if (index < 0) return false;
      const sprite = util.target.sprite;

      const soundId = sprite.sounds[index].soundId;
      const soundPlayer = sprite.soundBank.soundPlayers[soundId];

      if (!soundPlayer.outputNode) return false;
      return soundPlayer.outputNode.loop;
    }

    // https://github.com/scratchfoundation/scratch-vm/blob/7c1187cc1fe1c763ef61598875acd4fc9a0c8c2e/src/blocks/scratch3_sound.js#L164
    _playSoundAt(args, util, storeWaiting) {
      const index = this._getSoundIndex(args.SOUND, util);
      if (index >= 0) {
        const { target } = util;
        const { sprite } = target;
        const { soundId } = sprite.sounds[index];
        const start = Math.max(Scratch.Cast.toNumber(args.START), 0);
        const end =
          args.END == undefined ? undefined : Scratch.Cast.toNumber(args.END);
        if (sprite.soundBank) {
          if (storeWaiting === true) {
            // @ts-expect-error not typed
            Scratch.vm.runtime.ext_scratch3_sound._addWaitingSound(
              target.id,
              soundId
            );
          } else {
            // @ts-expect-error not typed
            Scratch.vm.runtime.ext_scratch3_sound._removeWaitingSound(
              target.id,
              soundId
            );
          }
          return this._playSoundBankSound(
            sprite.soundBank,
            target,
            soundId,
            start,
            end
          );
        }
      }
    }

    // https://github.com/scratchfoundation/scratch-audio/blob/6fb4b142a5f3198483e4c4f992fb623d5e9d1ed5/src/SoundBank.js#L89
    _playSoundBankSound(bank, target, soundId, start, end) {
      const effects = bank.getSoundEffects(soundId);
      const player = bank.getSoundPlayer(soundId);

      if (bank.playerTargets.get(soundId) !== target) {
        // make sure to stop the old sound, effectively "forking" the output
        // when the target switches before we adjust it's effects
        player.stop();
      }

      bank.playerTargets.set(soundId, target);
      effects.addSoundPlayer(player);
      effects.setEffectsFromTarget(target);
      player.connect(effects);

      this._playSoundPlayer(player, start, end);

      return player.finished();
    }

    // https://github.com/scratchfoundation/scratch-audio/blob/6fb4b142a5f3198483e4c4f992fb623d5e9d1ed5/src/SoundPlayer.js#L253
    _playSoundPlayer(player, start, end) {
      if (player.isStarting) {
        player.emit("stop");
        player.emit("play");
        return;
      }

      if (player.isPlaying) {
        player.stop();
      }

      if (player.initialized) {
        player._createSource();
      } else {
        player.initialize();
      }

      if (end === undefined) {
        player.outputNode.start(0, start);
      } else {
        player.outputNode.start(0, start, Math.max(end - start, 0));
      }

      player.isPlaying = true;

      const { currentTime, DECAY_DURATION } = player.audioEngine;
      player.startingUntil = currentTime + DECAY_DURATION;

      player.emit("play");
    }

    playSoundAt(args, util) {
      this._playSoundAt(args, util);
    }

    playSoundAtAndWait(args, util) {
      return this._playSoundAt(args, util, true);
    }

    playSoundTo(args, util) {
      this._playSoundAt(args, util);
    }

    playSoundToAndWait(args, util) {
      return this._playSoundAt(args, util, true);
    }

    stopSound(args, util) {
      const index = this._getSoundIndex(args.SOUND, util);
      if (index < 0) return 0;
      const target = util.target;
      const sprite = target.sprite;

      const soundId = sprite.sounds[index].soundId;
      const soundBank = sprite.soundBank;
      soundBank.stop(target, soundId);
    }

    pauseSounds(args, util) {
      this._toggleSoundState(args, util, true);
    }

    resumeSounds(args, util) {
      this._toggleSoundState(args, util, false);
    }

    _toggleSoundState(args, util, state) {
      const sprite = util.target.sprite;
      const audioContext = sprite.soundBank.audioEngine.audioContext;

      if (state) {
        audioContext.suspend();
        return;
      } else {
        audioContext.resume();
        return;
      }
    }

    isSoundPlaying(args, util) {
      const index = this._getSoundIndex(args.SOUND, util);
      if (index < 0) return false;
      const sprite = util.target.sprite;

      const soundId = sprite.sounds[index].soundId;
      const soundPlayers = sprite.soundBank.soundPlayers;
      return soundPlayers[soundId].isPlaying;
    }

    attributeOfSound(args, util) {
      const index = this._getSoundIndex(args.SOUND, util);
      if (index < 0) return 0;
      const sprite = util.target.sprite;

      const sound = sprite.sounds[index];
      const soundId = sound.soundId;
      const soundPlayer = sprite.soundBank.soundPlayers[soundId];
      const soundBuffer = soundPlayer.buffer;

      switch (args.ATTRIBUTE) {
        case "length":
          return Math.round(soundBuffer.duration * 100) / 100;
        case "channels":
          return soundBuffer.numberOfChannels;
        case "sample rate":
          return soundBuffer.sampleRate;
        case "dataURI":
          return sound.asset.encodeDataURI();
      }
    }

    getSoundEffect(args, util) {
      let target = Scratch.vm.runtime.getSpriteTargetByName(args.TARGET);
      if (args.TARGET === "_myself_") target = util.target;
      if (args.TARGET === "_stage_") target = runtime.getTargetForStage();
      const effects = target.soundEffects;
      if (!effects) return 0;
      return effects[args.EFFECT];
    }

    setProjectVolume(args) {
      const value = Scratch.Cast.toNumber(args.VALUE) / 100;
      const newVolume = Scratch.Cast.toNumber(Math.max(Math.min(value, 1), 0));
      runtime.audioEngine.inputNode.gain.value = newVolume;
    }

    changeProjectVolume(args) {
      const value = Scratch.Cast.toNumber(args.VALUE) / 100;
      const volume = runtime.audioEngine.inputNode.gain.value;
      const newVolume = Scratch.Cast.toNumber(
        Math.max(Math.min(volume + value, 1), 0)
      );
      runtime.audioEngine.inputNode.gain.value = newVolume;
    }

    getProjectVolume() {
      const volume = runtime.audioEngine.inputNode.gain.value;
      return Math.round(volume * 10000) / 100;
    }

    /* Utility Functions */

    _getSoundIndex(soundName, util) {
      const len = util.target.sprite.sounds.length;
      if (len === 0) {
        return -1;
      }
      const index = this._getSoundIndexByName(soundName, util);
      if (index !== -1) {
        return index;
      }
      const oneIndexedIndex = parseInt(soundName, 10);
      if (!isNaN(oneIndexedIndex)) {
        return this._wrapClamp(oneIndexedIndex - 1, 0, len - 1);
      }
      return -1;
    }

    _getSoundIndexByName(soundName, util) {
      const sounds = util.target.sprite.sounds;
      for (let i = 0; i < sounds.length; i++) {
        if (sounds[i].name === soundName) {
          return i;
        }
      }
      return -1;
    }

    _wrapClamp(n, min, max) {
      const range = max - min + 1;
      return n - Math.floor((n - min) / range) * range;
    }

    _getTargets() {
      let spriteNames = [
        { text: "myself", value: "_myself_" },
        { text: "Stage", value: "_stage_" },
      ];
      const targets = Scratch.vm.runtime.targets
        .filter((target) => target.isOriginal && !target.isStage)
        .map((target) => target.getName());
      spriteNames = spriteNames.concat(targets);
      return spriteNames;
    }
  }

  Scratch.extensions.register(new SoundExpanded());
})(Scratch);
