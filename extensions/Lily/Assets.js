// Name: Asset Manager
// ID: lmsAssets
// Description: Add, remove, and get data from various types of assets.
// License: MIT AND LGPL-3.0

// TheShovel is so epic and cool and awesome

/* generated l10n code */Scratch.translate.setup({"de":{"_Asset Manager":"Ressourcenverwaltung"},"fi":{"_Asset Manager":"Resurssienhallinta","_[ATTRIBUTE] of [COSTUME]":"asusteen [COSTUME] [ATTRIBUTE]","_[ATTRIBUTE] of [SOUND]":"äänen [SOUND] [ATTRIBUTE]","_add costume from URL [URL] named [NAME]":"lisää [NAME] -niminen asuste URL-osoitteesta [URL]","_add sound from URL [URL] named [NAME]":"lisää [NAME] -niminen ääni URL-osoitteesta [URL]","_add sprite from URL [URL]":"lisää hahmo URL-osoitteesta [URL]","_all costumes":"kaikki asusteet","_all sounds":"kaikki äänet","_all sprites":"kaikki hahmot","_asset ID":"resurssitunniste","_delete costume [COSTUME]":"poista asuste [COSTUME]","_delete sound [SOUND]":"poista ääni [SOUND]","_delete sprite [TARGET]":"poista hahmo [TARGET]","_format":"tiedostotyyppi","_header":"otsake","_index":"järjestysnumero","_load extension from URL [URL]":"lataa laajennus URL-osoitteesta [URL]","_loaded extensions":"ladatut laajennukset","_name of costume # [INDEX]":"[INDEX]. asusteen nimi","_name of sound # [INDEX]":"[INDEX]. äänen nimi","_open project from URL [URL]":"avaa projekti URL-osoitteesta [URL]","_project JSON":"projektin JSON-koodi","_rename costume [COSTUME] to [NAME]":"nimeä asuste [COSTUME] [NAME] -nimiseksi","_rename sound [SOUND] to [NAME]":"nimeä ääni [SOUND] [NAME] -nimiseksi","_rename sprite [TARGET] to [NAME]":"nimeä hahmo [TARGET] [NAME] -nimiseksi","_reorder costume # [INDEX1] to index [INDEX2]":"siirrä asusteluettelon [INDEX1]. asuste [INDEX2]:eksi","_reorder sound # [INDEX1] to index [INDEX2]":"siirrä ääniluettelon [INDEX1]. ääni [INDEX2]:eksi","_sprite name":"hahmon nimi"},"it":{"_Asset Manager":"Gestore Risorse","_index":"posizione"},"ja":{"_Asset Manager":"アセットマネージャー","_[ATTRIBUTE] of [COSTUME]":"[COSTUME]の[ATTRIBUTE]","_[ATTRIBUTE] of [SOUND]":"[SOUND]の[ATTRIBUTE]","_add costume from URL [URL] named [NAME]":"URL[URL]から名前[NAME]としてコスチュームを追加する","_add sound from URL [URL] named [NAME]":"URL[URL]から名前[NAME]として音を追加する","_add sprite from URL [URL]":"URL[URL]からスプライトを追加する","_all costumes":"すべてのコスチューム","_all sounds":"すべての音","_all sprites":"すべてのスプライト","_asset ID":"アセットID","_dataURI":"データURL","_delete costume [COSTUME]":"コスチューム[COSTUME]を削除する","_delete sound [SOUND]":"音[SOUND]を削除する","_delete sprite [TARGET]":"スプライト[TARGET]を削除する","_format":"フォーマット","_header":"ヘッダー","_load extension from URL [URL]":"拡張機能をURL[URL]から開く","_loaded extensions":"読み込まれた拡張機能","_name of costume # [INDEX]":"コスチューム[INDEX]番の名前","_name of sound # [INDEX]":"音[INDEX]番の名前","_open project from URL [URL]":"プロジェクトをURL[URL]から開く","_project JSON":"プロジェクトJSON","_rename costume [COSTUME] to [NAME]":"コスチューム[COSTUME]の名前を[NAME]に変更する","_rename sound [SOUND] to [NAME]":"音[SOUND]の名前を[NAME]に変更する","_rename sprite [TARGET] to [NAME]":"スプライト[TARGET]の名前を[NAME]に変更する","_reorder costume # [INDEX1] to index [INDEX2]":"コスチューム[INDEX1]番を[INDEX2]番に並べ替える","_reorder sound # [INDEX1] to index [INDEX2]":"音[INDEX1]番を[INDEX2]番に並べ替える","_sprite name":"スプライト名"},"ko":{"_Asset Manager":"에셋 매니저","_[ATTRIBUTE] of [COSTUME]":"[COSTUME]의 [ATTRIBUTE]","_[ATTRIBUTE] of [SOUND]":"[SOUND]의 [ATTRIBUTE]","_add costume from URL [URL] named [NAME]":"URL에서 모양 [NAME] 추가하기 [URL]","_add sound from URL [URL] named [NAME]":"URL에서 소리 [NAME] 추가하기 [URL]","_add sprite from URL [URL]":"URL에서 스프라이트 추가하기 [URL]","_all costumes":"모든 모양","_all sounds":"모든 소리","_all sprites":"모든 스프라이트","_asset ID":"에셋 ID","_delete costume [COSTUME]":"모양 [COSTUME] 삭제하기","_delete sound [SOUND]":"소리 [SOUND] 삭제하기","_delete sprite [TARGET]":"스프라이트 [TARGET] 삭제하기","_format":"파일 확장자","_header":"헤더","_index":"번째","_load extension from URL [URL]":"URL에서 확장 기능 불러오기 [URL]","_loaded extensions":"불러온 확장 기능 목록","_name of costume # [INDEX]":"모양 [INDEX]번째의 이름","_name of sound # [INDEX]":"소리 [INDEX]번째의 이름","_open project from URL [URL]":"URL에서 프로젝트 열기 [URL]","_project JSON":"프로젝트 JSON","_rename costume [COSTUME] to [NAME]":"모양 [COSTUME]의 이름을 [NAME](으)로 바꾸기","_rename sound [SOUND] to [NAME]":"소리 [SOUND]의 이름을 [NAME](으)로 바꾸기","_rename sprite [TARGET] to [NAME]":"스프라이트 [TARGET]의 이름을 [NAME](으)로 바꾸기","_reorder costume # [INDEX1] to index [INDEX2]":"모양 [INDEX1]번째를 [INDEX2]번째로 바꾸기","_reorder sound # [INDEX1] to index [INDEX2]":"소리 [INDEX1]번째를 [INDEX2]번째로 바꾸기","_sprite name":"스프라이트 이름"},"nb":{"_Asset Manager":"Eiendelsforvalter","_index":"indeks","_project JSON":"prosjekt JSON"},"nl":{"_Asset Manager":"Onderdelen beheren","_[ATTRIBUTE] of [COSTUME]":"[ATTRIBUTE] van [COSTUME]","_[ATTRIBUTE] of [SOUND]":"[ATTRIBUTE] van [SOUND]","_add costume from URL [URL] named [NAME]":"voeg uiterlijk toe van URL [URL] genaamd [NAME]","_add sound from URL [URL] named [NAME]":"voeg geluid toe van URL [URL] genaamd [NAME]","_add sprite from URL [URL]":"voeg sprite toe van URL [URL]","_all costumes":"alle uiterlijken","_all sounds":"alle geluiden","_all sprites":"alle sprites","_asset ID":"onderdeel-ID","_delete costume [COSTUME]":"verwijder uiterlijk [COSTUME]","_delete sound [SOUND]":"verwijder geluid [SOUND]","_delete sprite [TARGET]":"verwijder sprite [TARGET]","_format":"formaat","_load extension from URL [URL]":"laad extensie van URL [URL]","_loaded extensions":"geladen extensies","_name of costume # [INDEX]":"naam van uiterlijk # [INDEX]","_name of sound # [INDEX]":"naam van geluid # [INDEX]","_open project from URL [URL]":"open project van URL [URL]","_project JSON":"project-JSON","_rename costume [COSTUME] to [NAME]":"verander naam van uiterlijk [COSTUME] naar [NAME]","_rename sound [SOUND] to [NAME]":"verander naam van geluid [SOUND] naar [NAME]","_rename sprite [TARGET] to [NAME]":"verander naam van sprite [TARGET] naar [NAME]","_reorder costume # [INDEX1] to index [INDEX2]":"verplaats uiterlijk # [INDEX1] naar index [INDEX2] in lijst","_reorder sound # [INDEX1] to index [INDEX2]":"verplaats geluid # [INDEX1] naar index [INDEX2] in lijst","_sprite name":"naam van sprite"},"pl":{"_sprite name":"nazwa duszka"},"ru":{"_Asset Manager":"Менеджер Ресурсов","_[ATTRIBUTE] of [COSTUME]":"[ATTRIBUTE] костюма [COSTUME]","_[ATTRIBUTE] of [SOUND]":"[ATTRIBUTE] звука [SOUND]","_add costume from URL [URL] named [NAME]":"добавить костюм из URL-адреса [URL] названный [NAME]","_add sound from URL [URL] named [NAME]":"добавить звук из URL-адреса [URL] названный [NAME]","_add sprite from URL [URL]":"добавить спрайт из URL-адреса [URL]","_all costumes":"все костюмы","_all sounds":"все звуки","_all sprites":"все спрайты","_asset ID":"ID ресурса","_dataURI":"Хранилище Данных","_delete costume [COSTUME]":"удалить костюм [COSTUME]","_delete sound [SOUND]":"удалить звук [SOUND]","_delete sprite [TARGET]":"удалить спрайт [TARGET]","_format":"формат","_header":"заголовок","_index":"индекс","_load extension from URL [URL]":"загрузить расширение из URL-адреса [URL] ","_loaded extensions":"загруженные расширения","_name of costume # [INDEX]":"имя костюма # [INDEX]","_name of sound # [INDEX]":"имя звука # [INDEX]","_open project from URL [URL]":"открыть проект из URL-адреса [URL]","_project JSON":"JSON проекта","_rename costume [COSTUME] to [NAME]":"переименовать костюм [COSTUME] в [NAME]","_rename sound [SOUND] to [NAME]":"переименовать звук [SOUND] в [NAME]","_rename sprite [TARGET] to [NAME]":"переименовать спрайт [TARGET] в [NAME]","_reorder costume # [INDEX1] to index [INDEX2]":"пересортировать костюм # [INDEX1] в индекс [INDEX2]","_reorder sound # [INDEX1] to index [INDEX2]":"пересортировать звук # [INDEX1] в индекс [INDEX2]","_sprite name":"имя спрайта"},"tr":{"_Asset Manager":"Varlık Yöneticisi"},"uk":{"_Asset Manager":"Менеджер Ресурсів"},"zh-cn":{"_Asset Manager":"资源管理","_[ATTRIBUTE] of [COSTUME]":"[COSTUME]的[ATTRIBUTE]","_[ATTRIBUTE] of [SOUND]":"[SOUND]的[ATTRIBUTE]","_add costume from URL [URL] named [NAME]":"从URL[URL]加载造型[NAME]","_add sound from URL [URL] named [NAME]":"从URL[URL]加载声音[NAME]","_add sprite from URL [URL]":"从URL[URL]加载角色","_all costumes":"所有造型","_all sounds":"所有声音","_all sprites":"所有角色","_dataURI":"dataURL","_delete costume [COSTUME]":"删除造型[COSTUME]","_delete sound [SOUND]":"删除声音[SOUND]","_delete sprite [TARGET]":"删除角色[TARGET]","_format":"类型","_header":"具体类型","_index":"索引","_load extension from URL [URL]":"从URL[URL]加载拓展","_loaded extensions":"已加载的拓展","_name of costume # [INDEX]":"第[INDEX]个造型的名称","_name of sound # [INDEX]":"第[INDEX]个声音的名称","_open project from URL [URL]":"从URL[URL]加载项目","_project JSON":"当前项目数据","_rename costume [COSTUME] to [NAME]":"修改造型[COSTUME]的名称为[NAME]","_rename sound [SOUND] to [NAME]":"修改声音[SOUND]的名称为[NAME]","_rename sprite [TARGET] to [NAME]":"修改角色[TARGET]的名称为[NAME]","_reorder costume # [INDEX1] to index [INDEX2]":"将第 [INDEX1] 个造型切换到位置 [INDEX2]","_reorder sound # [INDEX1] to index [INDEX2]":"将第 [INDEX1]个音频切换到位置  [INDEX2]","_sprite name":"当前角色名称"}});/* end generated l10n code */(function (Scratch) {
  "use strict";

  const vm = Scratch.vm;
  const runtime = vm.runtime;
  const Cast = Scratch.Cast;

  const requireNonPackagedRuntime = (blockName) => {
    if (vm.runtime.isPackaged) {
      alert(
        `To use the Asset Manager ${blockName} block, the creator of the packaged project must uncheck "Remove raw asset data after loading to save RAM" under advanced settings in the packager.`
      );
      return false;
    }
    return true;
  };

  class Assets {
    getInfo() {
      return {
        id: "lmsAssets",
        color1: "#5779ca",
        color2: "#4e6db6",
        color3: "#4661a2",
        name: Scratch.translate("Asset Manager"),
        blocks: [
          {
            opcode: "addSprite",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("add sprite from URL [URL]"),
            arguments: {
              URL: {
                type: Scratch.ArgumentType.STRING,
              },
            },
          },
          {
            opcode: "addCostume",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("add costume from URL [URL] named [NAME]"),
            arguments: {
              URL: {
                type: Scratch.ArgumentType.STRING,
              },
              NAME: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "costume1",
              },
            },
          },
          {
            opcode: "addSound",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("add sound from URL [URL] named [NAME]"),
            arguments: {
              URL: {
                type: Scratch.ArgumentType.STRING,
              },
              NAME: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "sound1",
              },
            },
          },
          "---",
          {
            opcode: "renameSprite",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("rename sprite [TARGET] to [NAME]"),
            arguments: {
              TARGET: {
                type: Scratch.ArgumentType.STRING,
                menu: "targets",
              },
              NAME: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "Sprite1",
              },
            },
          },
          {
            opcode: "renameCostume",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("rename costume [COSTUME] to [NAME]"),
            arguments: {
              COSTUME: {
                type: Scratch.ArgumentType.COSTUME,
              },
              NAME: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "costume1",
              },
            },
          },
          {
            opcode: "renameSound",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("rename sound [SOUND] to [NAME]"),
            arguments: {
              SOUND: {
                type: Scratch.ArgumentType.SOUND,
              },
              NAME: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "sound1",
              },
            },
          },
          "---",
          {
            opcode: "deleteSprite",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("delete sprite [TARGET]"),
            arguments: {
              TARGET: {
                type: Scratch.ArgumentType.STRING,
                menu: "targets",
              },
              NAME: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "Sprite1",
              },
            },
          },
          {
            opcode: "deleteCostume",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("delete costume [COSTUME]"),
            arguments: {
              COSTUME: {
                type: Scratch.ArgumentType.COSTUME,
              },
              NAME: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "costume1",
              },
            },
          },
          {
            opcode: "deleteSound",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("delete sound [SOUND]"),
            arguments: {
              SOUND: {
                type: Scratch.ArgumentType.SOUND,
              },
              NAME: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "sound1",
              },
            },
          },
          "---",
          {
            opcode: "getAllSprites",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("all sprites"),
          },
          {
            opcode: "getAllCostumes",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("all costumes"),
          },
          {
            opcode: "getAllSounds",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("all sounds"),
          },
          {
            opcode: "getSpriteName",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("sprite name"),
          },
          "---",
          {
            opcode: "reorderCostume",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate(
              "reorder costume # [INDEX1] to index [INDEX2]"
            ),
            arguments: {
              INDEX1: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: "1",
              },
              INDEX2: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: "2",
              },
            },
          },
          {
            opcode: "reorderSound",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate(
              "reorder sound # [INDEX1] to index [INDEX2]"
            ),
            arguments: {
              INDEX1: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: "1",
              },
              INDEX2: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: "2",
              },
            },
          },
          "---",
          {
            opcode: "getSoundData",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("[ATTRIBUTE] of [SOUND]"),
            arguments: {
              ATTRIBUTE: {
                type: Scratch.ArgumentType.STRING,
                menu: "attribute",
              },
              SOUND: {
                type: Scratch.ArgumentType.SOUND,
              },
            },
          },
          {
            opcode: "getCostumeData",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("[ATTRIBUTE] of [COSTUME]"),
            arguments: {
              ATTRIBUTE: {
                type: Scratch.ArgumentType.STRING,
                menu: "attribute",
              },
              COSTUME: {
                type: Scratch.ArgumentType.COSTUME,
              },
            },
          },
          "---",
          {
            opcode: "getCostumeAtIndex",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("name of costume # [INDEX]"),
            arguments: {
              INDEX: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: "1",
              },
            },
          },
          {
            opcode: "getSoundAtIndex",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("name of sound # [INDEX]"),
            arguments: {
              INDEX: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: "1",
              },
            },
          },
          "---",
          {
            opcode: "openProject",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("open project from URL [URL]"),
            arguments: {
              URL: {
                type: Scratch.ArgumentType.STRING,
              },
            },
          },
          {
            opcode: "getProjectJSON",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("project JSON"),
          },
          "---",
          {
            opcode: "loadExtension",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("load extension from URL [URL]"),
            arguments: {
              URL: {
                type: Scratch.ArgumentType.STRING,
                defaultValue:
                  "https://extensions.turbowarp.org/Skyhigh173/json.js",
              },
            },
          },
          {
            opcode: "getLoadedExtensions",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("loaded extensions"),
          },
        ],
        menus: {
          targets: {
            acceptReporters: true,
            items: "_getTargets",
          },
          attribute: {
            acceptReporters: false,
            items: [
              {
                text: Scratch.translate("index"),
                value: "index",
              },
              {
                text: Scratch.translate("dataURI"),
                value: "dataURI",
              },
              {
                text: Scratch.translate("format"),
                value: "format",
              },
              {
                text: Scratch.translate("header"),
                value: "header",
              },
              {
                text: Scratch.translate("asset ID"),
                value: "asset ID",
              },
            ],
          },
        },
      };
    }

    async addSprite(args, util) {
      const url = Cast.toString(args.URL);

      const response = await Scratch.fetch(url);
      const json = await response.arrayBuffer();

      try {
        await vm.addSprite(json);
      } catch (e) {
        console.error(e);
      }
    }

    // Thank you PenguinMod for providing this code.
    async addCostume(args, util) {
      const targetId = util.target.id;
      const assetName = Cast.toString(args.NAME);

      const res = await Scratch.fetch(args.URL);
      const blob = await res.blob();

      if (!(this._typeIsBitmap(blob.type) || blob.type === "image/svg+xml")) {
        console.error(`Invalid MIME type: ${blob.type}`);
        return;
      }
      const assetType = this._typeIsBitmap(blob.type)
        ? runtime.storage.AssetType.ImageBitmap
        : runtime.storage.AssetType.ImageVector;

      // Bitmap data format is not actually enforced, but setting it to something that isn't in scratch-parser's
      // known format list will throw an error when someone tries to load the project.
      // (https://github.com/scratchfoundation/scratch-parser/blob/665f05d739a202d565a4af70a201909393d456b2/lib/sb3_definitions.json#L51)
      const dataType =
        blob.type === "image/svg+xml"
          ? runtime.storage.DataFormat.SVG
          : runtime.storage.DataFormat.PNG;

      const arrayBuffer = await new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.onerror = () =>
          reject(new Error(`Failed to read as array buffer: ${fr.error}`));
        fr.readAsArrayBuffer(blob);
      });

      const asset = runtime.storage.createAsset(
        assetType,
        dataType,
        new Uint8Array(arrayBuffer),
        null,
        true
      );
      const md5ext = `${asset.assetId}.${asset.dataFormat}`;

      try {
        await vm.addCostume(
          md5ext,
          {
            asset,
            md5ext,
            name: assetName,
          },
          targetId
        );
      } catch (e) {
        console.error(e);
      }
    }

    async addSound(args, util) {
      const targetId = util.target.id;
      const assetName = Cast.toString(args.NAME);

      const res = await Scratch.fetch(args.URL);
      const buffer = await res.arrayBuffer();

      const storage = runtime.storage;
      const asset = storage.createAsset(
        storage.AssetType.Sound,
        storage.DataFormat.MP3,
        new Uint8Array(buffer),
        null,
        true
      );

      try {
        await vm.addSound(
          {
            asset,
            md5: asset.assetId + "." + asset.dataFormat,
            name: assetName,
          },
          targetId
        );
      } catch (e) {
        console.error(e);
      }
    }
    // End of PenguinMod

    renameSprite(args, util) {
      const target = this._getTargetFromMenu(args.TARGET, util);
      if (!target || target.isStage) return;

      const name = Cast.toString(args.NAME);
      target.sprite.name = name;
    }

    renameCostume(args, util) {
      const target = util.target;
      const costumeName = Cast.toString(args.COSTUME);
      const costumeIndex = target.getCostumeIndexByName(costumeName);
      if (costumeIndex < 0) return;

      const name = Cast.toString(args.NAME);
      target.renameCostume(costumeIndex, name);
    }

    renameSound(args, util) {
      const target = util.target;
      const soundName = Cast.toString(args.SOUND);
      const soundIndex = this._getSoundIndexByName(soundName, util);
      if (soundIndex < 0) return;

      const name = Cast.toString(args.NAME);
      target.renameSound(soundIndex, name);
    }

    deleteSprite(args, util) {
      const target = this._getTargetFromMenu(args.TARGET);
      if (!target || target.isStage) return;

      Scratch.vm.deleteSprite(target.id);
    }

    deleteCostume(args, util) {
      const target = util.target;
      const costumeName = Cast.toString(args.COSTUME);
      const costumeIndex = target.getCostumeIndexByName(costumeName);
      if (costumeIndex < 0) return;

      if (target.sprite.costumes.length > 0) {
        target.deleteCostume(costumeIndex);
      }
    }

    deleteSound(args, util) {
      const target = util.target;
      const soundName = Cast.toString(args.SOUND);
      const soundIndex = this._getSoundIndexByName(soundName, util);
      if (soundIndex < 0) return;

      if (target.sprite.sounds.length > 0) {
        target.deleteSound(soundIndex);
      }
    }

    getAllSprites() {
      const spriteNames = [];
      const targets = Scratch.vm.runtime.targets;
      for (const target of targets) {
        // People reckoned the stage shouldn't be included
        if (target.isOriginal && !target.isStage) {
          spriteNames.push(target.sprite.name);
        }
      }
      return JSON.stringify(spriteNames);
    }

    getAllCostumes(args, util) {
      const costumeNames = [];
      const costumes = util.target.sprite.costumes;
      for (const costume of costumes) {
        costumeNames.push(costume.name);
      }
      return JSON.stringify(costumeNames);
    }

    getAllSounds(args, util) {
      const soundNames = [];
      const sounds = util.target.sprite.sounds;
      for (const sound of sounds) {
        soundNames.push(sound.name);
      }
      return JSON.stringify(soundNames);
    }

    getSpriteName(args, util) {
      return util.target.sprite.name ?? "";
    }

    reorderCostume(args, util) {
      const target = util.target;
      const index1 = Cast.toNumber(args.INDEX1) - 1;
      const index2 = Cast.toNumber(args.INDEX2) - 1;
      const costumes = target.sprite.costumes;

      if (index1 < 0 || index1 >= costumes.length) return;
      if (index2 < 0 || index2 >= costumes.length) return;

      target.reorderCostume(index1, index2);
    }

    reorderSound(args, util) {
      const target = util.target;
      const index1 = Cast.toNumber(args.INDEX1) - 1;
      const index2 = Cast.toNumber(args.INDEX2) - 1;
      const sounds = target.sprite.sounds;

      if (index1 < 0 || index1 >= sounds.length) return;
      if (index2 < 0 || index2 >= sounds.length) return;

      target.reorderSound(index1, index2);
    }

    getCostumeData(args, util) {
      const target = util.target;
      const attribute = Cast.toString(args.ATTRIBUTE);
      const costumeName = Cast.toString(args.COSTUME);
      const costumeIndex = target.getCostumeIndexByName(costumeName);
      if (costumeIndex < 0) return "";

      const costume = target.sprite.costumes[costumeIndex];
      switch (attribute) {
        case "dataURI":
          if (!requireNonPackagedRuntime("dataURI of costume")) return "";
          return costume.asset.encodeDataURI();
        case "index":
          return costumeIndex + 1;
        case "format":
          if (!requireNonPackagedRuntime("format of costume")) return "";
          return costume.asset.assetType.runtimeFormat;
        case "header":
          if (!requireNonPackagedRuntime("header of costume")) return "";
          return costume.asset.assetType.contentType;
        case "asset ID":
          if (!requireNonPackagedRuntime("asset ID of costume")) return "";
          return costume.asset.assetId;
        default:
          return "";
      }
    }

    getSoundData(args, util) {
      const target = util.target;
      const attribute = Cast.toString(args.ATTRIBUTE);
      const soundName = Cast.toString(args.SOUND);
      const soundIndex = this._getSoundIndexByName(soundName, util);
      if (soundIndex < 0) return "";

      const sound = target.sprite.sounds[soundIndex];
      switch (attribute) {
        case "dataURI":
          if (!requireNonPackagedRuntime("dataURI of sound")) return "";
          return sound.asset.encodeDataURI();
        case "index":
          return soundIndex + 1;
        case "format":
          if (!requireNonPackagedRuntime("format of sound")) return "";
          return sound.asset.assetType.runtimeFormat;
        case "header":
          if (!requireNonPackagedRuntime("header of sound")) return "";
          return sound.asset.assetType.contentType;
        case "asset ID":
          if (!requireNonPackagedRuntime("asset ID of sound")) return "";
          return sound.asset.assetId;
        default:
          return "";
      }
    }

    getCostumeAtIndex(args, util) {
      const target = util.target;
      const index = Math.round(Cast.toNumber(args.INDEX - 1));
      const costumes = target.sprite.costumes;
      if (index < 0 || index >= costumes.length) return "";

      return costumes[index].name;
    }

    getSoundAtIndex(args, util) {
      const target = util.target;
      const index = Math.round(Cast.toNumber(args.INDEX - 1));
      const sounds = target.sprite.sounds;
      if (index < 0 || index >= sounds.length) return "";

      return sounds[index].name;
    }

    openProject(args) {
      const url = Cast.toString(args.URL);
      Scratch.fetch(url)
        .then((r) => r.arrayBuffer())
        .then((buffer) => vm.loadProject(buffer));
    }

    getProjectJSON() {
      return Scratch.vm.toJSON();
    }

    async loadExtension(args) {
      const url = Cast.toString(args.URL);
      await vm.extensionManager.loadExtensionURL(url);
    }

    getLoadedExtensions(args) {
      return JSON.stringify(
        Array.from(vm.extensionManager._loadedExtensions.keys())
      );
    }

    /* Utility Functions */

    _getSoundIndexByName(soundName, util) {
      const sounds = util.target.sprite.sounds;
      for (let i = 0; i < sounds.length; i++) {
        if (sounds[i].name === soundName) {
          return i;
        }
      }
      return -1;
    }

    // PenguinMod
    _typeIsBitmap(type) {
      return (
        type === "image/png" ||
        type === "image/bmp" ||
        type === "image/jpg" ||
        type === "image/jpeg" ||
        type === "image/jfif" ||
        type === "image/webp" ||
        type === "image/gif"
      );
    }

    _getTargetFromMenu(targetName, util) {
      let target = Scratch.vm.runtime.getSpriteTargetByName(targetName);
      if (targetName === "_myself_") target = util.target.sprite.clones[0];
      return target;
    }

    _getTargets() {
      const spriteNames = [];
      if (Scratch.vm.editingTarget && !Scratch.vm.editingTarget.isStage) {
        spriteNames.push({
          text: "myself",
          value: "_myself_",
        });
      }
      const targets = Scratch.vm.runtime.targets;
      for (let index = 1; index < targets.length; index++) {
        const target = targets[index];
        if (target.isOriginal) {
          spriteNames.push(target.getName());
        }
      }
      if (spriteNames.length > 0) {
        return spriteNames;
      } else {
        return [""];
      }
    }
  }
  Scratch.extensions.register(new Assets());
})(Scratch);
