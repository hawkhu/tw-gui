// Name: Tween
// ID: jeremygamerTweening
// Description: Easing methods for smooth animations.
// By: JeremyGamer13 <https://scratch.mit.edu/users/JeremyGamer13/>
// License: MIT

/* generated l10n code */Scratch.translate.setup({"fi":{"_Tweening":"Interpolointi","_[MODE] ease [DIRECTION] [START] to [END] by [AMOUNT]%":"[MODE]-muotoinen [DIRECTION]pehmennys kohdasta [START] kohtaan [END] [AMOUNT] %:lla","_back":"taaksepäin","_bounce":"kimmoisuus","_circ":"ympyrä","_cubic":"kuutiollinen","_direction":"suunnaksi","_elastic":"joustava","_expo":"eksponentiaalinen","_in":"sisään","_in out":"sisään- ja ulos","_linear":"tasainen","_out":"ulos","_quad":"kvadraattinen","_quart":"neljäs aste","_quint":"viides aste","_sine":"sini","_size":"kooksi","_tween [PROPERTY] to [VALUE] over [SEC] seconds using [MODE] ease [DIRECTION]":"interpoloi [PROPERTY] [VALUE] [SEC] s:n aikana [MODE]-muotoisella [DIRECTION]pehmennyksellä","_tween to x: [X] y: [Y] over [SEC] seconds using [MODE] ease [DIRECTION]":"interpoloi sijaintiin x: [X] y: [Y] [SEC] s:n aikana [MODE]-muotoisella [DIRECTION]pehmennyksellä","_tween variable [VAR] to [VALUE] over [SEC] seconds using [MODE] ease [DIRECTION]":"interpoloi muuttuja [VAR] arvoon [VALUE] [SEC] s:n aikana [MODE]-muotoisella [DIRECTION]pehmennyksellä","_x position":"x-sijainniksi","_y position":"y-sijainniksi"},"it":{"_bounce":"elasticità"},"ja":{"_[MODE] ease [DIRECTION] [START] to [END] by [AMOUNT]%":"[MODE][DIRECTION][START]から[END]まで[AMOUNT]%緩める","_back":"戻る","_bounce":"バウンド","_circ":"サークル","_cubic":"キュービック","_direction":"方向","_elastic":"弾力性","_expo":"博覧会","_in":"イン","_in out":"イン アウト","_linear":"一次関数","_out":"アウト","_quad":"クワッド","_quart":"クォート","_quint":"五つ子","_sine":"正弦関数","_size":"サイズ","_tween [PROPERTY] to [VALUE] over [SEC] seconds using [MODE] ease [DIRECTION]":"[PROPERTY]を[VALUE]に[SEC]秒で[DIRECTION]を[MODE]を使って変える","_tween to x: [X] y: [Y] over [SEC] seconds using [MODE] ease [DIRECTION]":"[SEC] 秒かけて x:[X] y:[Y] にtweenします[MODE] イーズ [DIRECTION] を使用します","_tween variable [VAR] to [VALUE] over [SEC] seconds using [MODE] ease [DIRECTION]":"[MODE]イージー[DIRECTION]を使用して、変数[VAR]を[SEC]秒かけて[VALUE]にTweenします","_x position":"X 位置","_y position":"Y位置"},"ko":{"_Tweening":"트위닝","_[MODE] ease [DIRECTION] [START] to [END] by [AMOUNT]%":"[MODE] ease[DIRECTION] [START]에서 [END](으)로의 [AMOUNT]% 값","_direction":"방향","_in":"인","_in out":"인 아웃","_out":"아웃","_size":"크기","_tween [PROPERTY] to [VALUE] over [SEC] seconds using [MODE] ease [DIRECTION]":"[PROPERTY]을(를) [VALUE](으)로 [SEC]초 동안 [MODE] ease[DIRECTION] (으)로 바꾸기","_tween to x: [X] y: [Y] over [SEC] seconds using [MODE] ease [DIRECTION]":"x:[X] y:[Y] (으)로 [SEC]초 동안 [MODE] ease[DIRECTION] (으)로 이동하기","_tween variable [VAR] to [VALUE] over [SEC] seconds using [MODE] ease [DIRECTION]":"변수 [VAR]을(를) [VALUE](으)로 [SEC]초 동안 [MODE] ease[DIRECTION](으)로 바꾸기","_x position":"x좌표","_y position":"y좌표"},"nb":{"_bounce":"sprette"},"nl":{"_Tweening":"Overgangen","_[MODE] ease [DIRECTION] [START] to [END] by [AMOUNT]%":"overgang [MODE] [DIRECTION] van [START] naar [END] op [AMOUNT]%","_back":"terugslag","_bounce":"stuiter","_circ":"circulair","_cubic":"kubisch","_direction":"richting","_elastic":"elastisch","_expo":"exponentieel","_in out":"in uit","_out":"uit","_quad":"kwadratisch","_quart":"kwartisch","_quint":"kwintisch","_sine":"sinus","_size":"grootte","_tween [PROPERTY] to [VALUE] over [SEC] seconds using [MODE] ease [DIRECTION]":"animeer [PROPERTY] naar [VALUE] gedurende [SEC] seconden met overgang [MODE] [DIRECTION]","_tween to x: [X] y: [Y] over [SEC] seconds using [MODE] ease [DIRECTION]":"animeer naar x: [X] y: [Y] gedurende [SEC] seconden met overgang [MODE] [DIRECTION]","_tween variable [VAR] to [VALUE] over [SEC] seconds using [MODE] ease [DIRECTION]":"animeer variabele [VAR] naar [VALUE] gedurende [SEC] seconden met overgang [MODE] [DIRECTION]","_x position":"x-positie","_y position":"y-positie"},"pl":{"_direction":"kierunek","_size":"wielkość","_x position":"pozycja x","_y position":"pozycja y"},"ru":{"_Tweening":"Плавность","_[MODE] ease [DIRECTION] [START] to [END] by [AMOUNT]%":"[MODE] в [DIRECTION] [START] до [END] на [AMOUNT]%","_back":"назад","_bounce":"упругость","_circ":"циркулярно","_cubic":"кубически","_direction":"направление","_elastic":"эластично","_expo":"экспо","_in":"в","_in out":"в из","_linear":"линейно","_out":"из","_quad":"четырёхугольно","_quart":"квартово","_quint":"квинтово","_sine":"без","_size":"размер","_tween [PROPERTY] to [VALUE] over [SEC] seconds using [MODE] ease [DIRECTION]":"плавно [PROPERTY] значение [VALUE] на [SEC] секунд используя [MODE] в [DIRECTION]","_tween to x: [X] y: [Y] over [SEC] seconds using [MODE] ease [DIRECTION]":"плавно в x: [X] y: [Y] на [SEC] секунд используя [MODE] в [DIRECTION]","_tween variable [VAR] to [VALUE] over [SEC] seconds using [MODE] ease [DIRECTION]":"переменная плавности [VAR] значение [VALUE] на [SEC] секунд используя [MODE] в [DIRECTION]","_x position":"позиция x","_y position":"позиция y"},"zh-cn":{"_Tweening":"补间","_[MODE] ease [DIRECTION] [START] to [END] by [AMOUNT]%":"[MODE]缓[DIRECTION]从[START]到[END]进度[AMOUNT]%","_back":"回弹","_bounce":"弹性","_circ":"圆形","_cubic":"三次","_direction":"方向","_elastic":"弹跳","_expo":"指数","_in":"入","_in out":"入和出","_linear":"线性","_out":"出","_quad":"二次","_quart":"四次","_quint":"五次","_sine":"正弦","_size":"大小","_tween [PROPERTY] to [VALUE] over [SEC] seconds using [MODE] ease [DIRECTION]":"将[PROPERTY]在[SEC]秒内使用[MODE]缓[DIRECTION]渐变到[VALUE]","_tween to x: [X] y: [Y] over [SEC] seconds using [MODE] ease [DIRECTION]":"在[SEC]秒内使用[MODE]缓[DIRECTION]变速移到x:[X]y:[Y]","_tween variable [VAR] to [VALUE] over [SEC] seconds using [MODE] ease [DIRECTION]":"将变量[VAR]在[SEC]秒内使用[MODE]缓[DIRECTION]效果渐变到[VALUE]","_x position":"x坐标","_y position":"y坐标"}});/* end generated l10n code */(function (Scratch) {
  "use strict";

  const BlockType = Scratch.BlockType;
  const ArgumentType = Scratch.ArgumentType;
  const Cast = Scratch.Cast;

  /**
   * @param {number} time should be 0-1
   * @param {number} a value at 0
   * @param {number} b value at 1
   * @returns {number}
   */
  const interpolate = (time, a, b) => {
    // don't restrict range of time as some easing functions are expected to go outside the range
    const multiplier = b - a;
    const result = time * multiplier + a;
    return result;
  };

  const linear = (x) => x;

  const sine = (x, dir) => {
    switch (dir) {
      case "in": {
        return 1 - Math.cos((x * Math.PI) / 2);
      }
      case "out": {
        return Math.sin((x * Math.PI) / 2);
      }
      case "in out": {
        return -(Math.cos(Math.PI * x) - 1) / 2;
      }
      default:
        return 0;
    }
  };

  const quad = (x, dir) => {
    switch (dir) {
      case "in": {
        return x * x;
      }
      case "out": {
        return 1 - (1 - x) * (1 - x);
      }
      case "in out": {
        return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
      }
      default:
        return 0;
    }
  };

  const cubic = (x, dir) => {
    switch (dir) {
      case "in": {
        return x * x * x;
      }
      case "out": {
        return 1 - Math.pow(1 - x, 3);
      }
      case "in out": {
        return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
      }
      default:
        return 0;
    }
  };

  const quart = (x, dir) => {
    switch (dir) {
      case "in": {
        return x * x * x * x;
      }
      case "out": {
        return 1 - Math.pow(1 - x, 4);
      }
      case "in out": {
        return x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2;
      }
      default:
        return 0;
    }
  };

  const quint = (x, dir) => {
    switch (dir) {
      case "in": {
        return x * x * x * x * x;
      }
      case "out": {
        return 1 - Math.pow(1 - x, 5);
      }
      case "in out": {
        return x < 0.5
          ? 16 * x * x * x * x * x
          : 1 - Math.pow(-2 * x + 2, 5) / 2;
      }
      default:
        return 0;
    }
  };

  const expo = (x, dir) => {
    switch (dir) {
      case "in": {
        return x === 0 ? 0 : Math.pow(2, 10 * x - 10);
      }
      case "out": {
        return x === 1 ? 1 : 1 - Math.pow(2, -10 * x);
      }
      case "in out": {
        return x === 0
          ? 0
          : x === 1
            ? 1
            : x < 0.5
              ? Math.pow(2, 20 * x - 10) / 2
              : (2 - Math.pow(2, -20 * x + 10)) / 2;
      }
      default:
        return 0;
    }
  };

  const circ = (x, dir) => {
    switch (dir) {
      case "in": {
        return 1 - Math.sqrt(1 - Math.pow(x, 2));
      }
      case "out": {
        return Math.sqrt(1 - Math.pow(x - 1, 2));
      }
      case "in out": {
        return x < 0.5
          ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2
          : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2;
      }
      default:
        return 0;
    }
  };

  const back = (x, dir) => {
    switch (dir) {
      case "in": {
        const c1 = 1.70158;
        const c3 = c1 + 1;
        return c3 * x * x * x - c1 * x * x;
      }
      case "out": {
        const c1 = 1.70158;
        const c3 = c1 + 1;
        return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
      }
      case "in out": {
        const c1 = 1.70158;
        const c2 = c1 * 1.525;
        return x < 0.5
          ? (Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2
          : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;
      }
      default:
        return 0;
    }
  };

  const elastic = (x, dir) => {
    switch (dir) {
      case "in": {
        const c4 = (2 * Math.PI) / 3;
        return x === 0
          ? 0
          : x === 1
            ? 1
            : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4);
      }
      case "out": {
        const c4 = (2 * Math.PI) / 3;
        return x === 0
          ? 0
          : x === 1
            ? 1
            : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1;
      }
      case "in out": {
        const c5 = (2 * Math.PI) / 4.5;
        return x === 0
          ? 0
          : x === 1
            ? 1
            : x < 0.5
              ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) /
                2
              : (Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5)) /
                  2 +
                1;
      }
      default:
        return 0;
    }
  };

  const bounce = (x, dir) => {
    switch (dir) {
      case "in": {
        return 1 - bounce(1 - x, "out");
      }
      case "out": {
        const n1 = 7.5625;
        const d1 = 2.75;
        if (x < 1 / d1) {
          return n1 * x * x;
        } else if (x < 2 / d1) {
          return n1 * (x -= 1.5 / d1) * x + 0.75;
        } else if (x < 2.5 / d1) {
          return n1 * (x -= 2.25 / d1) * x + 0.9375;
        } else {
          return n1 * (x -= 2.625 / d1) * x + 0.984375;
        }
      }
      case "in out": {
        return x < 0.5
          ? (1 - bounce(1 - 2 * x, "out")) / 2
          : (1 + bounce(2 * x - 1, "out")) / 2;
      }
      default:
        return 0;
    }
  };

  const EasingMethods = {
    linear,
    sine,
    quad,
    cubic,
    quart,
    quint,
    expo,
    circ,
    back,
    elastic,
    bounce,
  };

  class Tween {
    getInfo() {
      return {
        id: "jeremygamerTweening",
        name: Scratch.translate("Tweening"),
        blocks: [
          {
            opcode: "tweenValue",
            text: Scratch.translate(
              "[MODE] ease [DIRECTION] [START] to [END] by [AMOUNT]%"
            ),
            disableMonitor: true,
            blockType: BlockType.REPORTER,
            arguments: {
              MODE: {
                type: ArgumentType.STRING,
                menu: "modes",
              },
              DIRECTION: {
                type: ArgumentType.STRING,
                menu: "direction",
              },
              START: {
                type: ArgumentType.NUMBER,
                defaultValue: 0,
              },
              END: {
                type: ArgumentType.NUMBER,
                defaultValue: 100,
              },
              AMOUNT: {
                type: ArgumentType.NUMBER,
                defaultValue: 50,
              },
            },
          },
          {
            opcode: "tweenVariable",
            text: Scratch.translate(
              "tween variable [VAR] to [VALUE] over [SEC] seconds using [MODE] ease [DIRECTION]"
            ),
            blockType: BlockType.COMMAND,
            arguments: {
              VAR: {
                type: ArgumentType.STRING,
                menu: "vars",
              },
              VALUE: {
                type: ArgumentType.NUMBER,
                defaultValue: 100,
              },
              SEC: {
                type: ArgumentType.NUMBER,
                defaultValue: 1,
              },
              MODE: {
                type: ArgumentType.STRING,
                menu: "modes",
              },
              DIRECTION: {
                type: ArgumentType.STRING,
                menu: "direction",
              },
            },
          },
          {
            opcode: "tweenXY",
            text: Scratch.translate(
              "tween to x: [X] y: [Y] over [SEC] seconds using [MODE] ease [DIRECTION]"
            ),
            blockType: BlockType.COMMAND,
            arguments: {
              PROPERTY: {
                type: ArgumentType.STRING,
                menu: "properties",
              },
              X: {
                type: ArgumentType.NUMBER,
                defaultValue: 100,
              },
              Y: {
                type: ArgumentType.NUMBER,
                defaultValue: 100,
              },
              SEC: {
                type: ArgumentType.NUMBER,
                defaultValue: 1,
              },
              MODE: {
                type: ArgumentType.STRING,
                menu: "modes",
              },
              DIRECTION: {
                type: ArgumentType.STRING,
                menu: "direction",
              },
            },
          },
          {
            opcode: "tweenProperty",
            text: Scratch.translate(
              "tween [PROPERTY] to [VALUE] over [SEC] seconds using [MODE] ease [DIRECTION]"
            ),
            blockType: BlockType.COMMAND,
            arguments: {
              PROPERTY: {
                type: ArgumentType.STRING,
                menu: "properties",
              },
              VALUE: {
                type: ArgumentType.NUMBER,
                defaultValue: 100,
              },
              SEC: {
                type: ArgumentType.NUMBER,
                defaultValue: 1,
              },
              MODE: {
                type: ArgumentType.STRING,
                menu: "modes",
              },
              DIRECTION: {
                type: ArgumentType.STRING,
                menu: "direction",
              },
            },
          },
        ],
        menus: {
          modes: {
            acceptReporters: true,
            items: [
              {
                text: Scratch.translate("linear"),
                value: "linear",
              },
              {
                text: Scratch.translate("sine"),
                value: "sine",
              },
              {
                text: Scratch.translate("quad"),
                value: "quad",
              },
              {
                text: Scratch.translate("cubic"),
                value: "cubic",
              },
              {
                text: Scratch.translate("quart"),
                value: "quart",
              },
              {
                text: Scratch.translate("quint"),
                value: "quint",
              },
              {
                text: Scratch.translate("expo"),
                value: "expo",
              },
              {
                text: Scratch.translate("circ"),
                value: "circ",
              },
              {
                text: Scratch.translate("back"),
                value: "back",
              },
              {
                text: Scratch.translate("elastic"),
                value: "elastic",
              },
              {
                text: Scratch.translate("bounce"),
                value: "bounce",
              },
            ],
          },
          direction: {
            acceptReporters: true,
            items: [
              {
                text: Scratch.translate("in"),
                value: "in",
              },
              {
                text: Scratch.translate("out"),
                value: "out",
              },
              {
                text: Scratch.translate("in out"),
                value: "in out",
              },
            ],
          },
          vars: {
            acceptReporters: false, // for Scratch parity
            items: "getVariables",
          },
          properties: {
            acceptReporters: true,
            items: [
              {
                text: Scratch.translate("x position"),
                value: "x position",
              },
              {
                text: Scratch.translate("y position"),
                value: "y position",
              },
              {
                text: Scratch.translate("direction"),
                value: "direction",
              },
              {
                text: Scratch.translate("size"),
                value: "size",
              },
            ],
          },
        },
      };
    }

    getVariables() {
      const variables =
        typeof Blockly === "undefined"
          ? []
          : Blockly.getMainWorkspace()
              .getVariableMap()
              // @ts-expect-error
              .getVariablesOfType("")
              .map((model) => ({
                text: model.name,
                value: model.getId(),
              }));
      if (variables.length > 0) {
        return variables;
      } else {
        return [{ text: "", value: "" }];
      }
    }

    tweenValue(args) {
      const easeMethod = Cast.toString(args.MODE);
      const easeDirection = Cast.toString(args.DIRECTION);
      const start = Cast.toNumber(args.START);
      const end = Cast.toNumber(args.END);
      const progress = Cast.toNumber(args.AMOUNT) / 100;

      if (!Object.prototype.hasOwnProperty.call(EasingMethods, easeMethod)) {
        // Unknown method
        return start;
      }
      const easingFunction = EasingMethods[easeMethod];

      const tweened = easingFunction(progress, easeDirection);
      return interpolate(tweened, start, end);
    }

    _tweenValue(args, util, id, valueArgName, currentValue) {
      // Only use args on first run. For later executions grab everything from stackframe.
      // This ensures that if the arguments change, the tweening won't change. This matches
      // the vanilla Scratch glide blocks.
      const state = util.stackFrame[id];

      if (!state) {
        // First run, need to start timer
        util.yield();

        // If multiple values being tweened in same block, only start timer stack timer once.
        if (util.stackTimerNeedsInit()) {
          const durationMS = Math.max(0, 1000 * Cast.toNumber(args.SEC));
          util.startStackTimer(durationMS);
        }

        const easeMethod = Cast.toString(args.MODE);
        const easeDirection = Cast.toString(args.DIRECTION);
        const start = currentValue;
        const end = Cast.toNumber(args[valueArgName]);

        let easingFunction;
        if (Object.prototype.hasOwnProperty.call(EasingMethods, easeMethod)) {
          easingFunction = EasingMethods[easeMethod];
        } else {
          easingFunction = EasingMethods.linear;
        }

        util.stackFrame[id] = {
          easingFunction,
          easeDirection,
          start,
          end,
        };

        return start;
      } else if (util.stackTimerFinished()) {
        // Done
        return util.stackFrame[id].end;
      } else {
        // Still running
        util.yield();

        const progress =
          util.stackFrame.timer.timeElapsed() / util.stackFrame.duration;
        const tweened = state.easingFunction(progress, state.easeDirection);
        return interpolate(tweened, state.start, state.end);
      }
    }

    tweenVariable(args, util) {
      const variable = util.target.lookupVariableById(args.VAR);
      const value = this._tweenValue(args, util, "", "VALUE", variable.value);
      if (variable && variable.type === "") {
        variable.value = value;
      }
    }

    tweenXY(args, util) {
      const x = this._tweenValue(args, util, "x", "X", util.target.x);
      const y = this._tweenValue(args, util, "y", "Y", util.target.y);
      util.target.setXY(x, y);
    }

    tweenProperty(args, util) {
      let currentValue = 0;
      if (args.PROPERTY === "x position") {
        currentValue = util.target.x;
      } else if (args.PROPERTY === "y position") {
        currentValue = util.target.y;
      } else if (args.PROPERTY === "direction") {
        currentValue = util.target.direction;
      } else if (args.PROPERTY === "size") {
        currentValue = util.target.size;
      }

      const value = this._tweenValue(args, util, "", "VALUE", currentValue);

      if (args.PROPERTY === "x position") {
        util.target.setXY(value, util.target.y);
      } else if (args.PROPERTY === "y position") {
        util.target.setXY(util.target.x, value);
      } else if (args.PROPERTY === "direction") {
        util.target.setDirection(value);
      } else if (args.PROPERTY === "size") {
        util.target.setSize(value);
      }
    }
  }

  Scratch.extensions.register(new Tween());
})(Scratch);
