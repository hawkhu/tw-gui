// Name: Zip
// ID: cst1229zip
// Description: Create and edit .zip format files, including .sb3 files.
// By: CST1229 <https://scratch.mit.edu/users/CST1229/>
// License: MIT AND LGPL-3.0

/* generated l10n code */Scratch.translate.setup({"fi":{"_1 (fast, large)":"1 (nopea, suuri)","_9 (slowest, smallest)":"9 (hitain, pienin)","_Copy of hello.txt":"Kopio hello-tiedostosta.txt","_Hello, world?":"Hei kaikki?","_URL":"URL-osoite","_Zip":"Pakkaa .zip:ksi","_[META] of [FILE]":"tiedoston [FILE] [META]","_[OBJECT] exists?":"onko [OBJECT] olemassa?","_any text":"tekstiä","_archive":"arkisto","_archive comment":"arkistokommentti","_archive is open?":"onko arkisto auki?","_binary":"binääri","_comment":"kommentti","_contents of directory [DIR]":"hakemiston [DIR] sisältö","_create directory [DIR]":"luo hakemisto [DIR]","_create empty archive named \"archive\"":"luo tyhjä \"arkisto\"-niminen arkisto","_create empty archive named [NAME]":"luo [NAME] -niminen arkisto","_current archive name":"nykyisen arkiston nimi","_current directory path":"nykyisen hakemiston polku","_currently open archives":"tällä hetkellä auki olevat arkistot","_delete [FILE]":"poista [FILE]","_error opening archive?":"tapahtuiko arkistoa avatessa virhe?","_file [FILE] as [TYPE]":"tiedosto [FILE] [TYPE]-tyyppisenä","_folder":"kansio","_go to directory [DIR]":"siirry hakemistoon [DIR]","_hex":"heksadesimaali","_long modification date":"pitkä muokkauspäivämäärä","_modification date":"muutospäivämäärä","_modified days since 2000":"muokkauspäivämäärä päivinä vuoden 2000 jälkeen","_name":"nimi","_new file":"uusi tiedosto","_new folder":"uusi kansio","_no compression (fastest)":"ei pakkausta (nopein)","_open archive from zip [TYPE] [DATA] named [NAME]":"avaa [NAME] -niminen arkisto zip-tiedostosta [TYPE] [DATA]","_open zip from [TYPE] [DATA] named \"archive\"":"avaa \"arkisto\"-niminen zip-tiedosto [TYPE] [DATA]","_other archive":"muu arkisto","_output zip type [TYPE] compression level [COMPRESSION]":"palauta [TYPE]-tyyppinen zip-tiedosto pakkaustasolla [COMPRESSION]","_path":"polku","_path [PATH] from [ORIGIN]":"lisää kansio [PATH] polkuun [ORIGIN]","_remove all archives":"poista kaikki arkistot","_remove current archive":"poista nykyinen arkisto","_set [META] of [FILE] to [VALUE]":"aseta tiedoston [FILE] [META] arvoon [VALUE]","_set archive comment to [COMMENT]":"aseta arkistokommentti arvoon [COMMENT]","_string":"merkkijono","_switch to archive named [NAME]":"vaihda [NAME] -nimiseen arkistoon","_text":"teksti","_unix modified timestamp":"muokkauspäivämäärä Unix-aikaleimana","_write file [FILE] content [CONTENT] type [TYPE]":"kirjoita tiedostoon [FILE] [TYPE] -tyyppinen sisältö [CONTENT]"},"it":{"_1 (fast, large)":"1 (veloce, grande)","_9 (slowest, smallest)":"9 (più lento, piccolo)","_Hello, world?":"Ciao mondo","_[META] of [FILE]":"[META] di [FILE]","_[OBJECT] exists?":"[OBJECT] esiste","_any text":"qualunque testo","_archive comment":"commento archivio","_archive is open?":"l'archivio è aperto","_binary":"binario","_comment":"commento","_contents of directory [DIR]":"contenuto della cartella [DIR]","_copy [FROM] in [FROMARCHIVE] to [TO] in [TOARCHIVE]":"copia [FROM] da [FROMARCHIVE] come [TO] in [TOARCHIVE]","_copy [FROM] to [TO]":"crea una copia di [FROM] come [TO]","_create directory [DIR]":"crea cartella [DIR]","_current directory path":"percorso cartella attuale","_delete [FILE]":"cancella [FILE]","_file [FILE] as [TYPE]":"file [FILE] come [TYPE]","_folder":"cartella","_go to directory [DIR]":"vai alla cartella [DIR]","_long modification date":"date modifica lunga","_modification date":"data modifica","_modified days since 2000":"giorni modifica dal 2000","_name":"nome","_new file":"nuovo file","_new folder":"nuova cartella","_no compression (fastest)":"nessuna compressione (più veloce)","_output zip type [TYPE] compression level [COMPRESSION]":"crea zip di tipo [TYPE] con livello di compressione [COMPRESSION]","_path":"percorso","_path [PATH] from [ORIGIN]":"percorso [PATH] da [ORIGIN]","_rename [FROM] to [TO]":"rinomina [FROM] come [TO]","_set [META] of [FILE] to [VALUE]":"imposta [META] di [FILE] a [VALUE]","_set archive comment to [COMMENT]":"imposta commento archivio a [COMMENT]","_string":"stringa","_text":"testo","_unix modified timestamp":"timestamp unix modifica","_write file [FILE] content [CONTENT] type [TYPE]":"scrivi file [FILE] con contenuto [CONTENT] e tipo [TYPE]"},"ja":{"_1 (fast, large)":"1(高速、大きい)","_9 (slowest, smallest)":"9(低速、小さい)","_Copy of hello.txt":"hello.txtのコピー","_Hello, world?":"こんにちは、世界?","_[META] of [FILE]":"[FILE]の[META]","_[OBJECT] exists?":"[OBJECT]は存在するか?","_any text":"何かのテキスト","_archive":"アーカイブ","_archive comment":"コメントをアーカイブする","_archive is open?":"アーカイブは開かれているか?","_binary":"バイナリ","_comment":"コメント","_contents of directory [DIR]":"[DIR]ディレクトリの内容","_create directory [DIR]":"[DIR] ディレクトリを作成","_create empty archive named \"archive\"":"空白のアーカイブ \"archive\"を作る","_create empty archive named [NAME]":"新しい空白のアーカイブ[NAME]を作る","_current archive name":"現在のアーカイブの名前","_current directory path":"現在のディレクトリパス","_currently open archives":"現在開いているアーカイブ","_data: URL":"データ: URL","_delete [FILE]":"[FILE]を消す","_error opening archive?":"開いているアーカイブにエラーが発生しているか?","_file [FILE] as [TYPE]":"ファイル[FILE]を[TYPE]として","_folder":"フォルダー","_go to directory [DIR]":"[DIR]ディレクトリへ行く","_long modification date":"詳細な最終更新日時","_modification date":"最終更新日時","_modified days since 2000":"2000年以降の変更された日数","_name":"名前","_new file":"新しいファイル","_new folder":"新しいフォルダ","_no compression (fastest)":"圧縮なし(最速)","_open archive from zip [TYPE] [DATA] named [NAME]":"アーカイブをzipから[TYPE]形式で[DATA]から[NAME]という名前で開く","_open zip from [TYPE] [DATA] named \"archive\"":"[TYPE][DATA]からarchiveという名前の zip を開く","_other archive":"他のアーカイブ","_output zip type [TYPE] compression level [COMPRESSION]":"出力ZIPタイプ[TYPE]の圧縮レベル[COMPRESSION]","_path":"パス","_path [PATH] from [ORIGIN]":"[ORIGIN]のパス[PATH]","_remove all archives":"すべてのアーカイブを削除する","_remove current archive":"現在のアーカイブを削除する","_set [META] of [FILE] to [VALUE]":"[FILE]の[META]を[VALUE]にセットする","_set archive comment to [COMMENT]":"アーカイブコメントを[COMMENT]にセットする","_string":"文字列","_switch to archive named [NAME]":"アーカイブを[NAME]という他のものに切り替える","_text":"テキスト","_unix modified timestamp":"UNIX変更タイムスタンプ","_write file [FILE] content [CONTENT] type [TYPE]":"ファイル[FILE]にコンテンツ[CONTENT]を[TYPE]型で書き込む"},"ko":{"_1 (fast, large)":"1 (빠름, 크기 큼)","_9 (slowest, smallest)":"9 (가장 느림, 크기 가장 작음)","_Copy of hello.txt":"hello.txt 의 복사본","_Hello, world?":"헬로 월드?","_[META] of [FILE]":"[FILE]의 [META]","_[OBJECT] exists?":"[OBJECT]이(가) 존재하는가?","_any text":"아무 텍스트","_archive":"아카이브","_archive comment":"아카이브 주석","_archive is open?":"아카이브가 열려있는가?","_binary":"바이너리","_comment":"주석","_contents of directory [DIR]":"디렉토리 [DIR]의 내용","_create directory [DIR]":"디렉토리 [DIR] 생성하기","_create empty archive named \"archive\"":"빈 아카이브 \"archive\" 생성하기","_create empty archive named [NAME]":"빈 아카이브 [NAME] 생성하기","_current archive name":"현재 아카이브의 이름","_current directory path":"현재 디렉토리 경로","_currently open archives":"열린 아카이브 목록","_delete [FILE]":"[FILE]을(를) 삭제하기","_error opening archive?":"아카이브를 여는 중 오류가 발생했는가?","_file [FILE] as [TYPE]":"파일 [FILE]을(를) [TYPE] 형식으로","_folder":"폴더","_go to directory [DIR]":"디렉토리 [DIR](으)로 이동하기","_hex":"Hex","_long modification date":"상세 수정 날짜","_modification date":"수정 날짜","_modified days since 2000":"2000년 부터 수정일 까지의 날짜 수","_name":"이름","_no compression (fastest)":"압축 없음 (가장 빠름)","_open archive from zip [TYPE] [DATA] named [NAME]":"아카이브 [NAME]을(를) [TYPE][DATA](으)로 열기 ","_open zip from [TYPE] [DATA] named \"archive\"":"아카이브 \"archive\"를 [TYPE][DATA](으)로 열기","_other archive":"다른 아카이브","_output zip type [TYPE] compression level [COMPRESSION]":"zip 타입[TYPE] 압축 레벨[COMPRESSION] (으)로 출력","_path":"경로","_path [PATH] from [ORIGIN]":"[ORIGIN]에서 [PATH] 경로로","_remove all archives":"모든 아카이브 삭제하기","_remove current archive":"현재 아카이브를 삭제하기","_set [META] of [FILE] to [VALUE]":"[FILE]의 [META]을(를) [VALUE](으)로 정하기","_set archive comment to [COMMENT]":"아카이브 주석을 [COMMENT](으)로 정하기","_string":"문자열","_switch to archive named [NAME]":"아카이브 [NAME](으)로 전환하기","_text":"텍스트","_unix modified timestamp":"unix 수정 타임스탬프","_write file [FILE] content [CONTENT] type [TYPE]":"새 파일 [FILE]을(를) [TYPE] 타입의 [CONTENT](으)로 쓰기"},"nb":{"_1 (fast, large)":"1 (rask, stor)","_9 (slowest, smallest)":"9 (tregeste, minste)","_Copy of hello.txt":"Kopi av hello.txt","_Hello, world?":"Hei, verden?","_[META] of [FILE]":"[META] av [FILE]","_[OBJECT] exists?":"[OBJECT] eksisterer?","_any text":"all tekst","_archive":"arkiv","_archive comment":"arkiver kommentar","_archive is open?":"arkivet er åpent?","_binary":"binær","_comment":"kommentar","_contents of directory [DIR]":"innholdet i katalogen [DIR]","_create directory [DIR]":"opprett katalog [DIR]","_create empty archive named [NAME]":"opprett tom arkiv med navn [NAME]","_current directory path":"gjeldende katalogbane","_delete [FILE]":"slett [FILE]","_file [FILE] as [TYPE]":"fil [FILE] som [TYPE]","_folder":"mappe","_go to directory [DIR]":"gå til katalogen [DIR]","_long modification date":"lang modifikasjonsdato","_modification date":"modifikasjonsdato","_modified days since 2000":"modifiserte dager siden 2000","_name":"navn","_new file":"ny fil","_new folder":"ny mappe","_no compression (fastest)":"ingen komprimering (raskest)","_open archive from zip [TYPE] [DATA] named [NAME]":"Open Archive fra zip [TYPE] [DATA] med navn [NAME]","_path":"sti","_path [PATH] from [ORIGIN]":"stien [PATH] fra [ORIGIN]","_remove current archive":"fjern gjeldende arkiv","_set [META] of [FILE] to [VALUE]":"sett [META] av [FILE] til [VALUE]","_set archive comment to [COMMENT]":"sett arkivkommentar til [COMMENT]","_text":"tekst","_unix modified timestamp":"unix endret tidsstempel","_write file [FILE] content [CONTENT] type [TYPE]":"skriv fil [FILE] innhold [CONTENT] type [TYPE]"},"nl":{"_1 (fast, large)":"1 (snel, groot)","_9 (slowest, smallest)":"9 (traagst, kleinst)","_Copy of hello.txt":"Kopie van hello.txt","_Hello, world?":"Hallo... wereld?","_[META] of [FILE]":"[META] van [FILE]","_[OBJECT] exists?":"[OBJECT] bestaat?","_any text":"tekst","_archive":"archief","_archive comment":"archiefopmerking","_archive is open?":"archief open?","_binary":"binair","_comment":"opmerking","_contents of directory [DIR]":"inhoud van map [DIR]","_create directory [DIR]":"creëer map [DIR]","_create empty archive named \"archive\"":"creëer leeg archief genaamd \"archive\"","_create empty archive named [NAME]":"creëer leeg archief genaamd [NAME]","_current archive name":"naam van huidig archief","_current directory path":"huidig map-pad","_currently open archives":"huidig geopende archieven","_delete [FILE]":"verwijder [FILE]","_error opening archive?":"archief openen mislukt?","_file [FILE] as [TYPE]":"bestand [FILE] als [TYPE]","_folder":"map","_go to directory [DIR]":"ga naar map [DIR]","_long modification date":"lange wijzigingsdatum","_modification date":"wijzigingsdatum","_modified days since 2000":"wijzigingsdatum in dagen sinds 2000","_name":"naam","_new file":"bestand","_new folder":"nieuwe map","_no compression (fastest)":"geen (snelst)","_open archive from zip [TYPE] [DATA] named [NAME]":"open archief van zip [TYPE] [DATA] genaamd [NAME]","_open zip from [TYPE] [DATA] named \"archive\"":"open zip van [TYPE] [DATA] genaamd \"archive\"","_other archive":"ander archief","_output zip type [TYPE] compression level [COMPRESSION]":"geef zip als uitvoer met soort [TYPE] en comprimeerniveau [COMPRESSION]","_path":"pad","_path [PATH] from [ORIGIN]":"pad [PATH] vanuit [ORIGIN] ","_remove all archives":"sluit alle archieven","_remove current archive":"sluit huidig archief","_set [META] of [FILE] to [VALUE]":"maak [META] van [FILE] [VALUE]","_set archive comment to [COMMENT]":"maak archiefopmerking [COMMENT]","_switch to archive named [NAME]":"schakel naar archief genaamd [NAME]","_text":"tekst","_unix modified timestamp":"wijzigingsdatum in unix-tijdstempel","_write file [FILE] content [CONTENT] type [TYPE]":"schrijf bestand [FILE] met inhoud [CONTENT] en soort [TYPE]"},"pl":{"_[META] of [FILE]":"[META] z [FILE]","_archive":"archiwum","_delete [FILE]":"usuń [FILE]","_name":"nazwa","_new file":"nowy plik","_new folder":"nowy folder","_text":"tekst"},"ru":{"_1 (fast, large)":"1 (быстрый, большой)","_9 (slowest, smallest)":"9 (самый медленный, самый маленький)","_Copy of hello.txt":"Скопировать hello.txt","_Hello, world?":"Привет, мир?","_URL":"URL-адрес","_Zip":"Архив","_[META] of [FILE]":"[META] файла [FILE] ","_[OBJECT] exists?":"[OBJECT] существует?","_any text":"любой текст","_archive":"архив","_archive comment":"комментарий к архиву","_archive is open?":"архив открыт?","_binary":"двоичный","_comment":"комментарий","_contents of directory [DIR]":"контент каталога [DIR]","_copy [FROM] in [FROMARCHIVE] to [TO] in [TOARCHIVE]":"скопировать [FROM] в [FROMARCHIVE] на [TO] в [TOARCHIVE]","_copy [FROM] to [TO]":"скопировать [FROM] на [TO]","_create directory [DIR]":"создать каталог [DIR]","_create empty archive named \"archive\"":"создать пустой архив названный \"archive\"","_create empty archive named [NAME]":"создать пустой архив названный [NAME]","_current archive name":"текущее имя архива","_current directory path":"текущий путь к каталогу","_currently open archives":"текущие открытые архивы","_data: URL":"данные: URL-адрес","_delete [FILE]":"удалить [FILE]","_error opening archive?":"ошибка при открытии архива?","_file [FILE] as [TYPE]":"файл [FILE] как [TYPE]","_folder":"папка","_go to directory [DIR]":"пойти к каталогу [DIR]","_long modification date":"длинная дата модификации","_modification date":"дата модификации","_modified days since 2000":"модифицированные дни с 2000 года","_name":"имя","_new file":"новый файл","_new folder":"новая папка","_no compression (fastest)":"отсутствие сжатия (самый быстрый)","_open archive from zip [TYPE] [DATA] named [NAME]":"открыть архив из zip [TYPE] [DATA] названным [NAME]","_open zip from [TYPE] [DATA] named \"archive\"":"открыть zip из [TYPE] [DATA] названный \"archive\"","_other archive":"другой архив","_output zip type [TYPE] compression level [COMPRESSION]":"выходной тип zip-файла [TYPE] уровень сжатия [COMPRESSION]","_path":"путь","_path [PATH] from [ORIGIN]":"путь [PATH] из [ORIGIN]","_remove all archives":"удалить все архивы","_remove current archive":"удалить текущий архив","_rename [FROM] to [TO]":"переименовать [FROM] на [TO]","_set [META] of [FILE] to [VALUE]":"задать [META] файла [FILE] в [VALUE]","_set archive comment to [COMMENT]":"задать комментарий к архиву со словами [COMMENT]","_string":"строка","_switch to archive named [NAME]":"сменить архиве на [NAME]","_text":"текст","_unix modified timestamp":"модифицированная временная метка unix","_write file [FILE] content [CONTENT] type [TYPE]":"Написать файл [FILE] с содержимым [CONTENT] типа [TYPE]"},"uk":{"_binary":"бінарно","_name":"ім'я","_text":"текст"},"zh-cn":{"_1 (fast, large)":"1（快，文件大）","_9 (slowest, smallest)":"9（慢，文件小）","_Copy of hello.txt":"hello-copied.txt","_Hello, world?":"你好世界？","_[META] of [FILE]":"[FILE]的[META]","_[OBJECT] exists?":"压缩包[OBJECT]存在？","_any text":"任意文本","_archive comment":"当前的注释","_archive is open?":"打开存档？","_binary":"二进制","_comment":"注释","_contents of directory [DIR]":"目录[DIR]的内容","_create directory [DIR]":"创建目录[DIR]","_create empty archive named \"archive\"":"创建新存档并命名为“archive”","_create empty archive named [NAME]":"创建新存档并命名为[NAME]","_current archive name":"打开的存档","_current directory path":"当前目录路径","_currently open archives":"打开的所有存档","_delete [FILE]":"删除文件[FILE]","_error opening archive?":"打开的存档有问题？","_file [FILE] as [TYPE]":"获取文件[FILE]的内容，类型是[TYPE]","_folder":"文件夹","_go to directory [DIR]":"到目录[DIR]","_hex":"Hex","_long modification date":"长修改日期","_modification date":"修改日期","_modified days since 2000":"自2000年以来的修改天数","_name":"名字","_new file":"新文件","_new folder":"新文件夹","_no compression (fastest)":"没有压缩（最快）","_open archive from zip [TYPE] [DATA] named [NAME]":"从zip[TYPE][DATA]打开存档并命名为[NAME]","_open zip from [TYPE] [DATA] named \"archive\"":"从zip[TYPE][DATA]打开存档并命名为“archive”","_output zip type [TYPE] compression level [COMPRESSION]":"输出类型是[TYPE]，压缩等级是[COMPRESSION]的压缩数据","_path":"路径","_path [PATH] from [ORIGIN]":"从[PATH]到[ORIGIN]的绝对路径","_remove all archives":"关闭所有存档","_remove current archive":"关闭当前存档","_set [META] of [FILE] to [VALUE]":"设置[FILE]的[META]为[VALUE]","_set archive comment to [COMMENT]":"设置注释为[COMMENT]","_string":"字符串","_switch to archive named [NAME]":"切换存档到[NAME]","_text":"文本","_unix modified timestamp":"修改时间的时间戳","_write file [FILE] content [CONTENT] type [TYPE]":"写入数据[CONTENT]，文件名是[FILE]，类型是[TYPE]"}});/* end generated l10n code */(function (Scratch) {
  "use strict";

  // @ts-expect-error - not typed yet
  const JSZip = Scratch.vm.exports.JSZip;

  const extIcon =
    "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMCAzMCI+PHJlY3Qgd2lkdGg9IjIzIiBoZWlnaHQ9IjIwIiB4PSI2IiB5PSIzIiBmaWxsPSIjZDhkODZjIiBzdHJva2U9IiM3ZDdkMjMiIHN0cm9rZS13aWR0aD0iMiIgcGFpbnQtb3JkZXI9InN0cm9rZSBtYXJrZXJzIGZpbGwiIHJ4PSI0IiByeT0iNCIgc3R5bGU9ImZvbnQtdmFyaWF0aW9uLXNldHRpbmdzOm5vcm1hbCIvPjxyZWN0IHdpZHRoPSIyOCIgaGVpZ2h0PSIyMCIgeD0iMSIgeT0iOCIgZmlsbD0iI2Q4ZDg2YyIgc3Ryb2tlPSIjN2Q3ZDIzIiBzdHJva2Utd2lkdGg9IjIiIHBhaW50LW9yZGVyPSJzdHJva2UgbWFya2VycyBmaWxsIiByeD0iNCIgcnk9IjQiIHN0eWxlPSJmb250LXZhcmlhdGlvbi1zZXR0aW5nczpub3JtYWwiLz48cGF0aCBmaWxsPSIjN2Q3ZDIzIiBkPSJNNSAxMlY3LjU1bDQtLjAyNlYxMlptMyA0di00aDR2NHptLTMgNHYtNGg0djR6bTMgNHYtNGg0djR6bS0zIDQuMTgxVjI0aDR2NC4xNzV6IiBzdHlsZT0ibWl4LWJsZW5kLW1vZGU6bm9ybWFsIi8+PHBhdGggZmlsbD0iIzdkN2QyMyIgc3Ryb2tlPSIjN2Q3ZDIzIiBzdHJva2Utd2lkdGg9Ii4xIiBkPSJNMTAgNy4xMjNWNWgydjIuMTM2Wk0xMSA1VjIuNTYybDItLjE2MlY1WiIgc3R5bGU9Im1peC1ibGVuZC1tb2RlOm5vcm1hbCIvPjxwYXRoIGZpbGw9IiNmZmYiIHN0cm9rZT0iIzdkN2QyMyIgc3Ryb2tlLXdpZHRoPSIyIiBkPSJNMTUuNDg3IDI0Ljh2LTEuNzY1bDUuNjczLTguNTJoLTUuNDkzVjEyLjRoOC40NTN2MS44OTdsLTUuNzExIDguMzg3aDUuNzg3VjI0Ljh6IiBhcmlhLWxhYmVsPSJaIiBmb250LWZhbWlseT0iQ29uc29sYXMiIGZvbnQtc2l6ZT0iMTkuNDMiIGZvbnQtd2VpZ2h0PSI3MDAiIHBhaW50LW9yZGVyPSJzdHJva2UgbWFya2VycyBmaWxsIiBzdHlsZT0iLWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjomcXVvdDtDb25zb2xhcywgQm9sZCZxdW90OyIgdHJhbnNmb3JtPSJzY2FsZSgxLjAzMyAuOTY4KSIvPjwvc3ZnPg==";

  class ZipExt {
    constructor() {
      this.zips = Object.create(null);
      // jszip has its own "go to directory" system, but it sucks
      // implement our own instead
      this.zipPaths = Object.create(null);
      this.zip = null;

      // for developers who want to integrate their extensions with this one
      // @ts-ignore
      Scratch.vm.runtime.ext_cst1229zip = this;

      this.zipError = false;

      Scratch.vm.runtime.on("RUNTIME_DISPOSED", () => {
        this.closeAll();
        this.zipError = false;
      });
    }

    getInfo() {
      return {
        id: "cst1229zip",
        name: Scratch.translate("Zip"),
        docsURI: "https://extensions.turbowarp.org/CST1229/zip",

        blockIconURI: extIcon,

        color1: "#a49a3a",
        color2: "#7d7d23",
        color3: "#666600",

        blocks: [
          {
            opcode: "createEmptyAs",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("create empty archive named [NAME]"),
            arguments: {
              NAME: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: Scratch.translate("archive"),
              },
            },
          },
          {
            opcode: "openAs",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate(
              "open archive from zip [TYPE] [DATA] named [NAME]"
            ),
            arguments: {
              TYPE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "URL",
                menu: "fileType",
              },
              DATA: {
                type: Scratch.ArgumentType.STRING,
                // defaultValue: "http:/localhost:8000/hello.zip",
                defaultValue: "https://extensions.turbowarp.org/hello.zip",
              },
              NAME: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: Scratch.translate("archive"),
              },
            },
          },

          // legacy blocks
          {
            hideFromPalette: true,
            opcode: "createEmpty",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate({
              default: 'create empty archive named "archive"',
              description:
                'Legacy block, not important to be translated. If you do, do not translate the name "archive"',
            }),
            arguments: {},
          },
          {
            hideFromPalette: true,
            opcode: "open",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate({
              default: 'open zip from [TYPE] [DATA] named "archive"',
              description:
                'Legacy block, not important to be translated. If you do, do not translate the name "archive"',
            }),
            arguments: {
              TYPE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "URL",
                menu: "fileType",
              },
              DATA: {
                type: Scratch.ArgumentType.STRING,
                // defaultValue: "http:/localhost:8000/hello.zip",
                defaultValue: "https://extensions.turbowarp.org/hello.zip",
              },
            },
          },
          {
            opcode: "getZip",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate(
              "output zip type [TYPE] compression level [COMPRESSION]"
            ),
            arguments: {
              TYPE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "data: URL",
                menu: "zipFileType",
              },
              COMPRESSION: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: "6",
                menu: "compressionLevel",
              },
            },
          },
          {
            opcode: "close",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("remove current archive"),
            arguments: {},
          },
          {
            opcode: "isOpen",
            blockType: Scratch.BlockType.BOOLEAN,
            text: Scratch.translate("archive is open?"),
            arguments: {},
          },
          {
            opcode: "isError",
            blockType: Scratch.BlockType.BOOLEAN,
            text: Scratch.translate("error opening archive?"),
            arguments: {},
          },

          "---",

          {
            opcode: "currentArchive",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("current archive name"),
            arguments: {},
          },
          {
            opcode: "listArchives",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("currently open archives"),
            arguments: {},
          },
          {
            opcode: "goToArchive",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("switch to archive named [NAME]"),
            arguments: {
              NAME: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: Scratch.translate("other archive"),
              },
            },
          },
          {
            opcode: "closeAll",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("remove all archives"),
            arguments: {},
          },

          "---",

          {
            opcode: "exists",
            blockType: Scratch.BlockType.BOOLEAN,
            text: Scratch.translate("[OBJECT] exists?"),
            arguments: {
              OBJECT: {
                type: Scratch.ArgumentType.STRING,
                // Don't translate so this matches the default zip
                defaultValue: "folder/",
              },
            },
          },
          {
            opcode: "writeFile",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate(
              "write file [FILE] content [CONTENT] type [TYPE]"
            ),
            arguments: {
              FILE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: `${Scratch.translate({
                  default: "new file",
                  description: "Default file name",
                })}.txt`,
              },
              TYPE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "text",
                menu: "writeFileType",
              },
              CONTENT: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: Scratch.translate("Hello, world?"),
              },
            },
          },
          {
            opcode: "renameFile",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("rename [FROM] to [TO]"),
            arguments: {
              FROM: {
                type: Scratch.ArgumentType.STRING,
                // Don't translate so matches default zip
                defaultValue: "hello.txt",
              },
              TO: {
                type: Scratch.ArgumentType.STRING,
                // Don't translate so matches default zip
                defaultValue: "hello renamed.txt",
              },
            },
          },
          {
            opcode: "copyFile",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("copy [FROM] to [TO]"),
            arguments: {
              FROM: {
                type: Scratch.ArgumentType.STRING,
                // Don't translate so matches default zip
                defaultValue: "hello.txt",
              },
              TO: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: Scratch.translate({
                  default: "Copy of hello.txt",
                  description:
                    "Windows reference. The \"hello.txt\" filename isn't translated, so don't translate it here",
                }),
              },
            },
          },
          {
            opcode: "copyFileToArchive",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate(
              "copy [FROM] in [FROMARCHIVE] to [TO] in [TOARCHIVE]"
            ),
            arguments: {
              FROM: {
                type: Scratch.ArgumentType.STRING,
                // Don't translate so matches default zip
                defaultValue: "hello.txt",
              },
              TO: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: Scratch.translate({
                  default: "Copy of hello.txt",
                  description:
                    "Windows reference. The \"hello.txt\" filename isn't translated, so don't translate it here",
                }),
              },
              FROMARCHIVE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: Scratch.translate("archive"),
              },
              TOARCHIVE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: Scratch.translate("other archive"),
              },
            },
          },
          {
            opcode: "deleteFile",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("delete [FILE]"),
            arguments: {
              FILE: {
                type: Scratch.ArgumentType.STRING,
                // Don't translate so matches default zip
                defaultValue: "hello.txt",
              },
            },
          },
          {
            opcode: "getFile",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("file [FILE] as [TYPE]"),
            arguments: {
              FILE: {
                type: Scratch.ArgumentType.STRING,
                // Don't translate so matches default zip
                defaultValue: "hello.txt",
              },
              TYPE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "text",
                menu: "getFileType",
              },
            },
          },

          "---",

          {
            opcode: "setFileMeta",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("set [META] of [FILE] to [VALUE]"),
            arguments: {
              META: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "modified days since 2000",
                menu: "setFileMeta",
              },
              FILE: {
                type: Scratch.ArgumentType.STRING,
                // Don't translate so matches default zip
                defaultValue: "folder/dango.png",
              },
              VALUE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "0",
              },
            },
          },
          {
            opcode: "getFileMeta",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("[META] of [FILE]"),
            arguments: {
              META: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "name",
                menu: "fileMeta",
              },
              FILE: {
                type: Scratch.ArgumentType.STRING,
                // Don't translate so matches default zip
                defaultValue: "folder/dango.png",
              },
            },
          },

          "---",

          {
            opcode: "createDir",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("create directory [DIR]"),
            arguments: {
              DIR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: Scratch.translate("new folder"),
              },
            },
          },
          {
            opcode: "goToDir",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("go to directory [DIR]"),
            arguments: {
              DIR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "folder",
              },
            },
          },
          {
            opcode: "getDir",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("contents of directory [DIR]"),
            arguments: {
              DIR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: ".",
              },
            },
          },
          {
            opcode: "currentDir",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("current directory path"),
          },

          "---",

          {
            opcode: "setComment",
            blockType: Scratch.BlockType.COMMAND,
            text: Scratch.translate("set archive comment to [COMMENT]"),
            arguments: {
              COMMENT: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: Scratch.translate("any text"),
              },
            },
          },
          {
            opcode: "getComment",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("archive comment"),
            arguments: {},
          },

          "---",

          {
            opcode: "normalizePath",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("path [PATH] from [ORIGIN]"),
            arguments: {
              PATH: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "../folder3/",
              },
              ORIGIN: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "/folder/folder2",
              },
            },
          },
        ],
        menus: {
          fileType: {
            // used in the open zip block
            acceptReporters: true,
            items: [
              {
                text: Scratch.translate("URL"),
                value: "URL",
              },
              {
                text: Scratch.translate("base64"),
                value: "base64",
              },
              {
                text: Scratch.translate("hex"),
                value: "hex",
              },
              {
                text: Scratch.translate("binary"),
                value: "binary",
              },
              {
                text: Scratch.translate("string"),
                value: "string",
              },
            ],
          },
          zipFileType: {
            // used in the output zip block
            acceptReporters: true,
            items: [
              {
                text: Scratch.translate("data: URL"),
                value: "data: URL",
              },
              {
                text: Scratch.translate("base64"),
                value: "base64",
              },
              {
                text: Scratch.translate("hex"),
                value: "hex",
              },
              {
                text: Scratch.translate("binary"),
                value: "binary",
              },
              {
                text: Scratch.translate("string"),
                value: "string",
              },
            ],
          },
          getFileType: {
            // used in the get file block
            acceptReporters: true,
            items: [
              {
                text: Scratch.translate("text"),
                value: "text",
              },
              {
                text: Scratch.translate("data: URL"),
                value: "data: URL",
              },
              {
                text: Scratch.translate("base64"),
                value: "base64",
              },
              {
                text: Scratch.translate("hex"),
                value: "hex",
              },
              {
                text: Scratch.translate("binary"),
                value: "binary",
              },
            ],
          },
          writeFileType: {
            // used in the write file block
            acceptReporters: true,
            items: [
              {
                text: Scratch.translate("text"),
                value: "text",
              },
              {
                text: Scratch.translate("URL"),
                value: "URL",
              },
              {
                text: Scratch.translate("base64"),
                value: "base64",
              },
              {
                text: Scratch.translate("hex"),
                value: "hex",
              },
              {
                text: Scratch.translate("binary"),
                value: "binary",
              },
            ],
          },
          compressionLevel: {
            acceptReporters: true,
            items: [
              {
                text: Scratch.translate("no compression (fastest)"),
                value: "0",
              },
              { text: Scratch.translate("1 (fast, large)"), value: "1" },
              { text: "2", value: "2" },
              { text: "3", value: "3" },
              { text: "4", value: "4" },
              { text: "5", value: "5" },
              { text: "6", value: "6" },
              { text: "7", value: "7" },
              { text: "8", value: "8" },
              { text: Scratch.translate("9 (slowest, smallest)"), value: "9" },
            ],
          },
          fileMeta: {
            acceptReporters: true,
            items: [
              {
                text: Scratch.translate("name"),
                value: "name",
              },
              {
                text: Scratch.translate("path"),
                value: "path",
              },
              {
                text: Scratch.translate("folder"),
                value: "folder",
              },
              {
                text: Scratch.translate("modification date"),
                value: "modification date",
              },
              {
                text: Scratch.translate("long modification date"),
                value: "long modification date",
              },
              {
                text: Scratch.translate("modified days since 2000"),
                value: "modified days since 2000",
              },
              {
                text: Scratch.translate("unix modified timestamp"),
                value: "unix modified timestamp",
              },
              {
                text: Scratch.translate("comment"),
                value: "comment",
              },
            ],
          },
          setFileMeta: {
            acceptReporters: true,
            items: [
              {
                text: Scratch.translate("modified days since 2000"),
                value: "modified days since 2000",
              },
              {
                text: Scratch.translate("unix modified timestamp"),
                value: "unix modified timestamp",
              },
              {
                text: Scratch.translate("comment"),
                value: "comment",
              },
            ],
          },
        },
      };
    }

    /// Utilities

    normalize(origin, path) {
      path = path.toString().replaceAll(/\\/g, "/");
      origin = origin.toString().replaceAll(/\\/g, "/");

      if (path.startsWith("/")) origin = "";
      else if (!origin.endsWith("/")) origin += "/";

      let parsedPath = origin + path;

      let split = parsedPath.split("/");

      let result = [];
      for (const i in split) {
        const part = split[i];
        if (part === ".") continue;
        if (part === "") {
          // First split of `/` is blank, so ignore in that case
          // Last split of a directory is also blank due to the /
          if (+i !== 0 && +i !== split.length - 1) {
            throw new Error("Cannot have empty directory names");
          }
          if (+i === 0) continue;
        }
        if (part === "..") {
          if (result.length <= 0) {
            throw new Error("Cannot go above root");
          }
          result.pop();
          continue;
        }
        result.push(part);
      }
      return "/" + result.join("/");
    }
    splitIntoParts(string, partLength) {
      const arr = [];
      for (let i = 0; i < string.length; i += partLength) {
        arr.push(string.substring(i, i + partLength));
      }
      return arr;
    }
    // get a file/folder by path
    getObj(path, zip = this.zip) {
      // JSZip.prototype.files seems to be a null-prototype object
      // it should be safe doing this
      return (
        this.zips[zip].files[path.substring(1)] || this.zips[zip].files[path]
      );
    }
    // create folders up to a certain path
    createFolders(path, zip) {
      try {
        path = this.normalize(path, ".");

        let currentPath = "";
        for (const folder of path.split("/")) {
          if (folder === "") continue;
          if (currentPath !== "") currentPath += "/";
          currentPath += folder;
          zip.folder(currentPath);
        }
      } catch (e) {
        console.error(`Zip extension: Error creating folders for ${path}:`, e);
      }
    }
    // Go back until we are in a directory that exists
    goBackFolders(zip) {
      const split = this.zipPaths[zip].split("/");
      this.zipPaths[zip] = "";

      let i = 0;
      while (i < split.length) {
        if (split[i] === "") {
          i++;
          continue;
        }
        const newPath = this.zipPaths[zip] + split[i] + "/";
        if (!this.getObj(newPath, zip)) break;
        this.zipPaths[zip] = newPath;
        i++;
      }
      if (this.zipPaths[zip] === "") this.zipPaths[zip] = "/";
    }

    /// Blocks

    createEmptyAs({ NAME }) {
      this.zipError = false;
      NAME = Scratch.Cast.toString(NAME);
      if (!NAME) {
        this.zipError = true;
        return;
      }

      this.zip = NAME;

      this.zips[this.zip] = new JSZip();
      this.zipPaths[this.zip] = "/";
    }
    createEmpty() {
      this.createEmptyAs({ NAME: "archive" });
    }

    async openAs({ TYPE, DATA, NAME }) {
      this.zipError = false;
      this.zip = null;
      NAME = Scratch.Cast.toString(NAME);
      if (!NAME) {
        this.zipError = true;
        return;
      }

      try {
        DATA = Scratch.Cast.toString(DATA);

        switch (TYPE) {
          case "base64":
          case "data: URL":
          case "URL":
            {
              if (TYPE === "base64")
                DATA = "data:application/zip;base64," + DATA;
              const resp = await Scratch.fetch(DATA);
              DATA = await resp.blob();
            }
            break;
          case "hex":
            {
              if (!/^(?:[0-9A-F]{2})*$/i.test(DATA)) return;
              const dataArr = this.splitIntoParts(DATA, 2);
              DATA = Uint8Array.from(dataArr.map((o) => parseInt(o, 16)));
            }
            break;
          case "binary":
            {
              if (!/^(?:[01]{8})*$/i.test(DATA)) return;
              const dataArr = this.splitIntoParts(DATA, 8);
              DATA = Uint8Array.from(dataArr.map((o) => parseInt(o, 2)));
            }
            break;
        }

        this.zip = NAME;

        this.zips[this.zip] = await JSZip.loadAsync(DATA, {
          createFolders: true,
        });
        this.zipPaths[this.zip] = "/";
      } catch (e) {
        this.zipError = true;
        this.zip = null;
        console.error("Zip extension: Could not open zip file.", e);
      }
    }
    open({ TYPE, DATA }) {
      return this.openAs({ TYPE, DATA, NAME: "archive" });
    }
    async getZip({ TYPE, COMPRESSION }) {
      if (!this.zip) return "";
      try {
        COMPRESSION = Scratch.Cast.toNumber(COMPRESSION);
        COMPRESSION = Math.max(Math.min(Math.round(COMPRESSION), 9), 0);

        const compType = COMPRESSION === 0 ? "STORE" : "DEFLATE";
        const options = {
          compression: compType,
          compressionOptions: { level: COMPRESSION },
        };

        switch (TYPE) {
          case "text":
          case "string":
            return await this.zips[this.zip].generateAsync({
              type: "binarystring",
              ...options,
            });
          case "base64":
          case "data: URL": {
            let data = await this.zips[this.zip].generateAsync({
              type: "base64",
              ...options,
            });
            if (TYPE === "data: URL")
              data = "data:application/zip;base64," + data;
            return data;
          }
          case "hex": {
            const data = await this.zips[this.zip].generateAsync({
              type: "array",
              ...options,
            });
            return data
              .map((data) => data.toString(16).padStart(2, "0"))
              .join("");
          }
          case "binary": {
            const data = await this.zips[this.zip].generateAsync({
              type: "array",
              ...options,
            });
            return data
              .map((data) => data.toString(2).padStart(8, "0"))
              .join("");
          }
          default:
            return "";
        }
      } catch (e) {
        console.error(
          `Zip extension: Error creating zip with type ${TYPE} compression ${COMPRESSION}:`,
          e
        );
      }
    }
    close() {
      delete this.zips[this.zip];
      delete this.zipPaths[this.zip];
      this.zip = null;
    }
    closeAll() {
      this.zips = Object.create(null);
      this.zipPaths = Object.create(null);
      this.zip = null;
    }
    isOpen() {
      return !!this.zip;
    }
    isError() {
      return this.zipError;
    }

    currentArchive() {
      if (!this.zip) return "";
      return this.zip;
    }
    goToArchive({ NAME }) {
      NAME = Scratch.Cast.toString(NAME);
      if (!NAME) {
        this.zip = null;
        return;
      }
      if (!this.zips[NAME]) return;

      this.zip = NAME;
    }
    listArchives() {
      return JSON.stringify(Object.keys(this.zips));
    }

    exists({ OBJECT }) {
      try {
        return !!this.getObj(
          this.normalize(this.zipPaths[this.zip], Scratch.Cast.toString(OBJECT))
        );
      } catch (e) {
        return false;
      }
    }
    async getFile({ FILE, TYPE }) {
      if (!this.zip) return "";

      FILE = Scratch.Cast.toString(FILE);
      TYPE = Scratch.Cast.toString(TYPE);
      try {
        const path = this.normalize(this.zipPaths[this.zip], FILE);
        if (path.endsWith("/")) return "";
        const obj = this.getObj(path);
        if (!obj || obj.dir) return "";

        switch (TYPE) {
          case "text":
            return await obj.async("string");
          case "base64":
          case "data: URL": {
            let data = await obj.async("base64");
            if (TYPE === "data: URL")
              data = "data:application/octet-stream;base64," + data;
            return data;
          }
          case "hex": {
            const data = await obj.async("array");
            return data
              .map((data) => data.toString(16).padStart(2, "0"))
              .join("");
          }
          case "binary": {
            const data = await obj.async("array");
            return data
              .map((data) => data.toString(2).padStart(8, "0"))
              .join("");
          }
          default:
            return "";
        }
      } catch (e) {
        console.error(
          `Zip extension: Error getting file ${FILE} with type ${TYPE}:`,
          e
        );
        return "";
      }
    }
    async writeFile({ FILE, CONTENT, TYPE }) {
      if (!this.zip) return;

      FILE = Scratch.Cast.toString(FILE);
      CONTENT = Scratch.Cast.toString(CONTENT);
      TYPE = Scratch.Cast.toString(TYPE);
      try {
        let path = this.normalize(this.zipPaths[this.zip], FILE);
        if (path.endsWith("/")) return;

        const obj = this.getObj(path);
        if (obj && obj.dir) return;

        if (path.startsWith("/")) path = path.substring(1);

        switch (TYPE) {
          case "text":
            this.zips[this.zip].file(path, CONTENT, {
              createFolders: true,
            });
            break;
          case "base64":
          case "data: URL": {
            // compatibility
            if (TYPE === "data: URL")
              CONTENT = CONTENT.substring(CONTENT.indexOf(","));
            this.zips[this.zip].file(path, CONTENT, {
              base64: true,
              createFolders: true,
            });
            break;
          }
          case "URL":
            {
              const resp = await Scratch.fetch(CONTENT);
              this.zips[this.zip].file(path, await resp.blob(), {
                base64: true,
                createFolders: true,
              });
            }
            break;
          case "hex":
            {
              if (!/^(?:[0-9A-F]{2})*$/i.test(CONTENT)) return "";
              const dataArr = this.splitIntoParts(CONTENT, 2);
              const data = Uint8Array.from(dataArr.map((o) => parseInt(o, 16)));
              this.zips[this.zip].file(path, data, {
                createFolders: true,
              });
            }
            break;
          case "binary":
            {
              if (!/^(?:[01]{8})*$/i.test(CONTENT)) return "";
              const dataArr = this.splitIntoParts(CONTENT, 8);
              const data = Uint8Array.from(dataArr.map((o) => parseInt(o, 2)));
              this.zips[this.zip].file(path, data, {
                createFolders: true,
              });
            }
            break;
          default:
            return "";
        }
      } catch (e) {
        console.error(
          `Zip extension: Error writing to file ${FILE} type ${TYPE}:`,
          e
        );
      }
    }

    async _renameFile(from, fromZipName, to, toZipName, isCopy) {
      const renameOne = async (from, fromZip, to, toZip) => {
        if (from === to && fromZip == toZip) return;
        const obj = fromZip.files[from];
        if (isCopy) {
          let copied;
          if (obj.dir) {
            copied = toZip.folder(to);
          } else {
            copied = toZip.file(to, await obj.async("uint8array"), obj.options);
          }
          // copy properties over
          copied.date = structuredClone(obj.date);
          copied.dosPermissions = obj.dosPermissions;
          copied.unixPermissions = obj.unixPermissions;
          copied.comment = obj.comment;
        } else {
          toZip.files[to] = obj;
          obj.name = to;
          delete fromZip.files[from];
        }
      };

      let fromZip = this.zips[fromZipName];
      let toZip = this.zips[toZipName];
      if (!fromZip || !toZip) return;

      try {
        let fromPath = this.normalize(this.zipPaths[fromZipName], from);
        let fromObj = this.getObj(fromPath, fromZipName);
        if (!fromObj && !fromPath.endsWith("/")) {
          fromPath += "/";
          fromObj = this.getObj(fromPath, fromZipName);
        }
        if (!fromObj) return;
        let toPath = this.normalize(this.zipPaths[toZipName], to);
        const replacedTo = to.replaceAll(/\\/g, "/");
        const slashes = replacedTo.split("/").length - 1;
        if (
          slashes <= +fromObj.dir &&
          (slashes === 0 || replacedTo.endsWith("/"))
        ) {
          // this is a name-only change
          toPath = this.normalize(fromPath, "../" + replacedTo);
          if (fromObj.dir) {
            if (!fromPath.endsWith("/")) fromPath += "/";
          } else {
            if (fromPath.endsWith("/")) return;
          }
        }

        if (fromPath.startsWith("/")) fromPath = fromPath.substring(1);
        if (toPath.startsWith("/")) toPath = toPath.substring(1);

        // If this is a file, just renaming this one is enough
        if (!fromObj.dir) {
          await renameOne(fromPath, fromZip, toPath, toZip);
          return;
        }

        // Otherwise, we need to rename this object
        // and everything else in it
        if (!toPath.endsWith("/")) toPath += "/";

        // Move current directory
        if (
          !isCopy &&
          this.zipPaths[fromZipName].substring(1).startsWith(fromPath)
        ) {
          if (fromZip === toZip) {
            this.zipPaths[fromZipName] =
              "/" +
              toPath +
              this.zipPaths[fromZipName]
                .substring(1)
                .substring(fromPath.length);
          } else {
            this.goBackFolders(fromZip);
          }
        }

        for (const path in fromZip.files) {
          if (!path.startsWith(fromPath)) continue;
          const extraPath = path.substring(fromPath.length);
          await renameOne(path, fromZip, toPath + extraPath, toZip);
        }
        this.createFolders(toPath, toZip);
      } catch (e) {
        console.error(
          `Zip extension: Error ${isCopy ? "copying" : "renaming"} ${from} to ${to}:`,
          e
        );
      }
    }

    renameFile({ FROM, TO }) {
      if (!this.zip) return;

      FROM = Scratch.Cast.toString(FROM);
      TO = Scratch.Cast.toString(TO);
      this._renameFile(FROM, this.zip, TO, this.zip, false);
    }
    copyFile({ FROM, TO }) {
      if (!this.zip) return;

      FROM = Scratch.Cast.toString(FROM);
      TO = Scratch.Cast.toString(TO);
      this._renameFile(FROM, this.zip, TO, this.zip, true);
    }
    copyFileToArchive({ FROM, FROMARCHIVE, TO, TOARCHIVE }) {
      if (!this.zip) return;

      FROM = Scratch.Cast.toString(FROM);
      FROMARCHIVE = Scratch.Cast.toString(FROMARCHIVE);
      TO = Scratch.Cast.toString(TO);
      TOARCHIVE = Scratch.Cast.toString(TOARCHIVE);
      this._renameFile(FROM, FROMARCHIVE, TO, TOARCHIVE, true);
    }
    deleteFile({ FILE }) {
      if (!this.zip) return;

      FILE = Scratch.Cast.toString(FILE);
      try {
        let path = this.normalize(this.zipPaths[this.zip], FILE);
        if (!this.getObj(path)) return;
        if (path === "/") return;

        const shouldGoBack =
          this.getObj(path).dir && this.zipPaths[this.zip].startsWith(path);
        if (path.startsWith("/")) path = path.substring(1);

        this.zips[this.zip].remove(path);

        if (shouldGoBack) {
          this.goBackFolders(this.zip);
        }
      } catch (e) {
        console.error(`Zip extension: Error deleting file ${FILE}:`, e);
      }
    }

    setFileMeta({ META, FILE, VALUE }) {
      if (!this.zip) return;

      META = Scratch.Cast.toString(META);
      FILE = Scratch.Cast.toString(FILE);
      VALUE = Scratch.Cast.toString(VALUE);
      try {
        const normalized = this.normalize(this.zipPaths[this.zip], FILE);
        const obj = this.getObj(normalized);
        if (!obj) return "";
        switch (META) {
          case "modified days since 2000":
            {
              const msPerDay = 24 * 60 * 60 * 1000;
              const start = +new Date(2000, 0, 1);
              obj.date = new Date(
                start + Scratch.Cast.toNumber(VALUE) * msPerDay
              );
            }
            break;
          case "unix modified timestamp":
            obj.date = new Date(Scratch.Cast.toNumber(VALUE));
            break;
          case "comment":
            obj.comment = VALUE;
            break;
          default:
            return;
        }
      } catch (e) {
        console.error(`Zip extension: Error getting ${META} of ${FILE}:`, e);
        return "";
      }
    }
    getFileMeta({ META, FILE }) {
      if (!this.zip) return "";

      META = Scratch.Cast.toString(META);
      FILE = Scratch.Cast.toString(FILE);
      try {
        const normalized = this.normalize(this.zipPaths[this.zip], FILE);
        const obj = this.getObj(normalized);
        if (!obj) return "";
        switch (META) {
          case "name": {
            const splitPath = obj.name.split("/");
            // Directories have an extra slash at the end
            // (obj.dir is casted to 0 or 1)
            return splitPath[splitPath.length - 1 - +obj.dir] || "";
          }
          case "path":
            return "/" + obj.name;
          case "folder": {
            /** @type {Array} */
            const splitPath = obj.name.split("/");
            const folders = splitPath
              .slice(0, splitPath.length - 1 - +obj.dir)
              .join("/");
            return "/" + folders + (folders === "" ? "" : "/");
          }
          case "modification date":
            return obj.date.toLocaleString(navigator.language);
          case "long modification date":
            return new Date().toLocaleString(navigator.language, {
              dateStyle: "full",
              timeStyle: "medium",
            });
          case "modified days since 2000": {
            const msPerDay = 24 * 60 * 60 * 1000;
            const start = +new Date(2000, 0, 1);
            return (+obj.date - start) / msPerDay;
          }
          case "unix modified timestamp":
            return +obj.date;
          case "comment":
            return obj.comment || "";
          default:
            return "";
        }
      } catch (e) {
        console.error(`Zip extension: Error getting ${META} of ${FILE}:`, e);
        return "";
      }
    }

    createDir({ DIR }) {
      if (!this.zip) return;
      DIR = Scratch.Cast.toString(DIR);
      try {
        let newPath = this.normalize(this.zipPaths[this.zip], DIR);
        if (!newPath.endsWith("/")) newPath += "/";
        if (newPath.startsWith("/")) newPath = newPath.substring(1);
        if (this.getObj(newPath)) return;
        this.zips[this.zip].folder(newPath);
      } catch (e) {
        console.error(`Error creating directory ${DIR}:`, e);
      }
    }
    goToDir({ DIR }) {
      if (!this.zip) return;
      DIR = Scratch.Cast.toString(DIR);
      try {
        let newPath = this.normalize(this.zipPaths[this.zip], DIR);
        if (!newPath.endsWith("/")) newPath += "/";
        if (!this.getObj(newPath) && newPath !== "/") return;
        this.zipPaths[this.zip] = newPath;
      } catch (e) {
        console.error(`Error going to directory ${DIR}:`, e);
      }
    }
    getDir({ DIR }) {
      if (!this.zip) return "";
      try {
        DIR = Scratch.Cast.toString(DIR);
        if (!DIR.endsWith("/")) DIR += "/";

        const normalized = this.normalize(this.zipPaths[this.zip], DIR);
        if (!this.getObj(normalized) && normalized !== "/") return "";
        const dir = normalized.substring(1);
        const length = dir.length;

        return JSON.stringify(
          Object.values(this.zips[this.zip].files)
            .filter((obj) => {
              // Above the current directory
              if (!obj.name.startsWith(dir)) return false;
              // Below the current directory
              if (obj.name.substring(length).split("/").length > obj.dir + 1)
                return false;
              // Is the current directory
              if (obj.name === dir) return false;
              return true;
            })
            .map((obj) => obj.name.substring(length))
        );
      } catch (e) {
        console.error(`Zip extension: Could not get directory ${DIR}:`, e);
        return "";
      }
    }
    currentDir() {
      return this.zipPaths[this.zip] || "";
    }

    setComment({ COMMENT }) {
      if (!this.zip) return;
      this.zips[this.zip].comment = Scratch.Cast.toString(COMMENT);
    }
    getComment({ COMMENT }) {
      if (!this.zip) return "";
      return this.zips[this.zip].comment || "";
    }

    normalizePath({ ORIGIN, PATH }) {
      try {
        return this.normalize(
          Scratch.Cast.toString(ORIGIN),
          Scratch.Cast.toString(PATH)
        );
      } catch (e) {
        return "";
      }
    }
  }

  // @ts-ignore
  Scratch.extensions.register(new ZipExt());
})(globalThis.Scratch);
